#[cfg(not(feature = "geode"))]
use crate::{game::PlayLayer, hooks};

use crate::{
    clickpack::{Button, ClickType, Clickpack, LoadClickpackFor, Pitch, Timings, VolumeSettings},
    utils,
};
use anyhow::Result;
use egui::{
    emath, epaint::Shadow, vec2, Color32, DragValue, Key, KeyboardShortcut, Modifiers, RichText,
};
use egui_clickpack_db::ClickpackDb;
use egui_keybind::{Bind, Keybind, Shortcut};
use egui_modal::{Icon, Modal};
use egui_notify::{Toast, Toasts};
use kittyaudio::{Device, Mixer, PlaybackRate, SoundHandle, StreamSettings};
use once_cell::sync::Lazy;
use parking_lot::Mutex;
use rfd::FileDialog;
use serde::{Deserialize, Serialize};
use std::{
    ops::RangeInclusive,
    path::{Path, PathBuf},
    process::Command,
    sync::{
        atomic::{AtomicBool, Ordering},
        Arc,
    },
    time::{Duration, Instant},
};

#[cfg(not(feature = "geode"))]
use windows::Win32::System::Console::{AllocConsole, FreeConsole};

/// Global bot state
///
/// # Safety
/// This static is accessed from multiple contexts but is designed to be used
/// in a single-threaded environment (the main game thread). The warnings about
/// static mut references are acknowledged but the current design ensures safety
/// through careful usage patterns.
#[allow(static_mut_refs)]
pub static mut BOT: Lazy<Box<Bot>> = Lazy::new(Box::<Bot>::default);

const UI_SCALE_RANGE: RangeInclusive<f32> = 0.3..=5.0;

pub mod built_info {
    // generated by build.rs
    include!(concat!(env!("OUT_DIR"), "/built.rs"));
}

#[derive(Serialize, Deserialize, Clone, PartialEq)]
pub struct Shortcuts {
    pub toggle_menu: Shortcut,
    pub toggle_bot: Shortcut,
    pub toggle_noise: Shortcut,
}

impl Default for Shortcuts {
    fn default() -> Self {
        Self {
            toggle_menu: Shortcut::new(
                Some(KeyboardShortcut::new(Modifiers::NONE, Key::Num1)),
                None,
            ),
            toggle_bot: Shortcut::new(
                Some(KeyboardShortcut::new(Modifiers::NONE, Key::Num2)),
                None,
            ),
            toggle_noise: Shortcut::NONE,
        }
    }
}

fn skip_serializing_selected_device(device: &str) -> bool {
    let is_default = if let Ok(name) = Device::Default.name() {
        name == device
    } else {
        false
    };
    device.is_empty() || is_default
}

#[derive(Serialize, Deserialize, Default, Clone, Debug, PartialEq)]
pub enum ClickpackEnv {
    #[default]
    None,
    Name(String),
    Path(PathBuf),
}

#[derive(Serialize, Deserialize, Clone)]
pub struct Env {
    version: String,
    clickpack_ord: Vec<(ClickpackEnv, LoadClickpackFor)>,
    is_first_launch: bool,
    #[serde(
        default = "String::new",
        skip_serializing_if = "skip_serializing_selected_device"
    )]
    pub selected_device: String,
}

impl Default for Env {
    fn default() -> Self {
        Self {
            version: built_info::PKG_VERSION.to_string(),
            clickpack_ord: vec![(ClickpackEnv::None, LoadClickpackFor::All)],
            is_first_launch: true, // overriden later
            selected_device: String::new(),
        }
    }
}

impl Env {
    pub fn load() -> Self {
        let _ = std::fs::create_dir_all(".zcb")
            .map_err(|e| log::error!("failed to create .zcb directory: {e}"));

        let path = Path::new(".zcb/env.json");
        if let Ok(f) = std::fs::File::open(path) {
            let env = serde_json::from_reader(f);
            if let Ok(env) = env {
                return env;
            } else if let Err(e) = env {
                log::error!("failed to deserialize env: {e}");
            }
        }

        // if we're here we failed
        log::warn!("failed to deserialize env, writing defaults");
        if let Ok(f) = std::fs::File::create(path) {
            let _ = serde_json::to_writer_pretty(f, &Self::default())
                .map_err(|e| log::error!("failed to write env: {e}"));
        }

        Self::default()
    }

    pub fn save(&self) {
        log::info!("writing .zcb/env.json");
        let mut env = self.clone();
        env.version = built_info::PKG_VERSION.to_string();
        if let Ok(f) = std::fs::File::create(".zcb/env.json") {
            let _ = serde_json::to_writer_pretty(f, &env)
                .map_err(|e| log::error!("failed to write env: {e}"));
        }
    }

    pub fn update(&mut self, clickpack_env: ClickpackEnv, load_for: LoadClickpackFor) {
        match load_for {
            LoadClickpackFor::All => self.clickpack_ord = vec![(clickpack_env, load_for)],
            _ => {
                self.clickpack_ord.retain(|ord| ord.1 != load_for);
                log::info!("pushing to ord: ({clickpack_env:?}, {load_for:?})");
                self.clickpack_ord.push((clickpack_env, load_for));
            }
        }
        self.save();
    }

    // fn is_selected_by_path(&self) -> bool {
    //     self.clickpack_ord
    //         .iter()
    //         .any(|c| matches!(c.0, ClickpackEnv::Path(_)))
    // }
}

const fn true_value() -> bool {
    true
}

const fn default_buffer_size() -> u32 {
    512
}

#[inline]
fn float_one<Num: emath::Numeric>() -> Num {
    Num::from_f64(1.0)
}

// clickpack, options, audio
#[derive(Serialize, Deserialize, Clone, PartialEq, Default, Copy)]
pub enum Stage {
    #[default]
    Clickpack,
    Audio,
    Options,
}

#[derive(Serialize, Deserialize, Clone, PartialEq, Default)]
struct IgnoredClickTypes {
    hardclicks: bool,
    hardreleases: bool,
    softclicks: bool,
    softreleases: bool,
    clicks: bool,
    releases: bool,
    microclicks: bool,
    microreleases: bool,
}

impl IgnoredClickTypes {
    #[inline]
    const fn is_ignored(&self, typ: ClickType) -> bool {
        match typ {
            ClickType::HardClick => self.hardclicks,
            ClickType::HardRelease => self.hardreleases,
            ClickType::SoftClick => self.softclicks,
            ClickType::SoftRelease => self.softreleases,
            ClickType::Click => self.clicks,
            ClickType::Release => self.releases,
            ClickType::MicroClick => self.microclicks,
            ClickType::MicroRelease => self.microreleases,
            ClickType::None => true,
        }
    }

    #[inline]
    const fn any_ignored(&self) -> bool {
        self.hardclicks
            || self.hardreleases
            || self.softclicks
            || self.softreleases
            || self.clicks
            || self.releases
            || self.microclicks
            || self.microreleases
    }
}

const fn death_release_delay_default() -> f64 {
    0.001
}

const fn death_release_delay_offset_default() -> f64 {
    0.13
}

const fn default_time_smoothing_factor() -> f64 {
    0.1 // 10% smoothing for stable timing
}

const fn default_pause_detection_threshold() -> f64 {
    0.1 // 100ms threshold for detecting pauses
}

const fn default_input_latency_compensation() -> f64 {
    0.0 // No compensation by default
}

const fn default_allow_audio_finish_on_pause() -> bool {
    true // Allow audio to finish naturally when paused
}

const fn default_pause_debounce_threshold() -> f64 {
    0.05 // 50ms debounce threshold for pause state changes
}

const fn default_rapid_pause_threshold() -> u32 {
    5 // Maximum rapid pause/resume cycles before triggering audio reset
}

#[derive(Debug, Clone)]
pub enum PendingAudioAction {
    Play { button: Button, player2: bool, push: bool, timestamp: Instant },
    Stop { immediate: bool },
    Reset,
}

#[derive(Serialize, Deserialize, Clone, Copy, PartialEq, Default)]
pub enum TimingMode {
    #[default]
    Responsive, // Prioritizes immediate audio response
    Synchronized, // Prioritizes perfect recording sync
    Hybrid, // Balances both (recommended)
}

impl TimingMode {
    const fn text(self) -> &'static str {
        match self {
            TimingMode::Responsive => "Responsive (Live Play)",
            TimingMode::Synchronized => "Synchronized (Recording)",
            TimingMode::Hybrid => "Hybrid (Balanced)",
        }
    }
}

#[derive(Serialize, Deserialize, Clone, Copy, PartialEq, Default)]
pub enum ToastVisibility {
    #[default]
    AlwaysVisible,
    VisibleWhenOpen,
    NeverVisible,
}

impl ToastVisibility {
    #[inline]
    const fn text(self) -> &'static str {
        match self {
            ToastVisibility::AlwaysVisible => "Always Visible",
            ToastVisibility::VisibleWhenOpen => "Visible in Menu",
            ToastVisibility::NeverVisible => "Never Visible",
        }
    }
}

#[derive(Serialize, Deserialize, Clone, PartialEq)]
pub struct Config {
    pub pitch_enabled: bool,
    pub pitch: Pitch,
    pub timings: Timings,
    pub volume_settings: VolumeSettings,
    #[serde(default = "Shortcuts::default")]
    pub shortcuts: Shortcuts,
    #[serde(default = "true_value")]
    pub enabled: bool,
    #[serde(default = "bool::default")]
    pub hidden: bool,
    #[serde(default = "default_buffer_size")]
    pub buffer_size: u32,
    #[serde(default = "bool::default")]
    pub play_noise: bool,
    #[serde(default = "float_one")]
    pub noise_volume: f64,
    #[serde(default = "bool::default")]
    pub force_playing_platformer: bool,
    #[serde(default = "bool::default")]
    pub use_alternate_hook: bool,
    #[serde(default = "bool::default")]
    pub show_console: bool,
    #[serde(default = "Stage::default")]
    pub stage: Stage,
    #[serde(default = "bool::default")]
    pub use_fmod: bool,
    #[serde(default = "bool::default")]
    pub cut_sounds: bool,
    #[serde(default = "bool::default")]
    pub cut_by_releases: bool,
    #[serde(default = "float_one")]
    pub click_speedhack: f64,
    // #[serde(default = "true_value")]
    // pub sync_speed_with_game: bool,
    #[serde(default = "float_one")]
    pub noise_speedhack: f64,
    #[serde(default = "LoadClickpackFor::default")]
    pub load_clickpack_for: LoadClickpackFor,
    #[serde(default = "bool::default")]
    pub decouple_platformer: bool,
    #[serde(default = "true_value")]
    pub autosave_config: bool,
    #[serde(default = "true_value")]
    pub release_buttons_on_death: bool,
    #[serde(default = "death_release_delay_default")]
    pub death_release_delay: f64,
    #[serde(default = "death_release_delay_offset_default")]
    pub death_release_delay_offset: f64,
    #[serde(default = "bool::default")]
    pub death_release_delay_neg: bool,
    #[serde(default = "bool::default")]
    pub force_player2_sounds: bool,
    #[serde(default = "bool::default")]
    pub play_noise_when_disabled: bool,
    #[serde(default = "IgnoredClickTypes::default")]
    ignored_click_types: IgnoredClickTypes,
    #[serde(default = "bool::default")]
    pub use_ingame_time: bool,
    #[serde(default = "bool::default")]
    pub enhanced_recording_sync: bool,
    #[serde(default = "default_time_smoothing_factor")]
    pub time_smoothing_factor: f64,
    #[serde(default = "default_pause_detection_threshold")]
    pub pause_detection_threshold: f64,
    #[serde(default = "true_value")]
    pub instant_audio_response: bool,
    #[serde(default = "default_input_latency_compensation")]
    pub input_latency_compensation: f64,
    #[serde(default = "TimingMode::default")]
    pub timing_mode: TimingMode,
    #[serde(default = "default_allow_audio_finish_on_pause")]
    pub allow_audio_finish_on_pause: bool,
    #[serde(default = "default_pause_debounce_threshold")]
    pub pause_debounce_threshold: f64,
    #[serde(default = "default_rapid_pause_threshold")]
    pub rapid_pause_threshold: u32,
    #[serde(default = "bool::default")]
    pub enable_audio_system_recovery: bool,
    #[serde(default = "float_one")]
    pub ui_scale: f32,
    #[serde(default)]
    pub toast_visibility: ToastVisibility,
}

impl Config {
    #[inline]
    pub fn fixup(mut self) -> Self {
        self.buffer_size = self.buffer_size.max(1);
        #[cfg(feature = "geode")]
        {
            self.show_console = false;
        }
        self.ui_scale = self
            .ui_scale
            .clamp(*UI_SCALE_RANGE.start(), *UI_SCALE_RANGE.end());
        self
    }
}

impl Default for Config {
    fn default() -> Self {
        Self {
            pitch_enabled: true,
            pitch: Pitch::default(),
            timings: Timings::default(),
            volume_settings: VolumeSettings::default(),
            shortcuts: Shortcuts::default(),
            enabled: true,
            hidden: false,
            buffer_size: default_buffer_size(),
            play_noise: false,
            noise_volume: 1.0,
            force_playing_platformer: false,
            use_alternate_hook: false,
            show_console: false,
            stage: Stage::default(),
            use_fmod: false,
            cut_sounds: false,
            cut_by_releases: false,
            click_speedhack: 1.0,
            noise_speedhack: 1.0,
            load_clickpack_for: LoadClickpackFor::All,
            decouple_platformer: false,
            autosave_config: true,
            release_buttons_on_death: true,
            death_release_delay: death_release_delay_default(),
            death_release_delay_offset: death_release_delay_offset_default(),
            death_release_delay_neg: false,
            force_player2_sounds: false,
            play_noise_when_disabled: false,
            ignored_click_types: IgnoredClickTypes::default(),
            use_ingame_time: false,
            enhanced_recording_sync: false,
            time_smoothing_factor: default_time_smoothing_factor(),
            pause_detection_threshold: default_pause_detection_threshold(),
            instant_audio_response: true,
            input_latency_compensation: default_input_latency_compensation(),
            timing_mode: TimingMode::default(),
            allow_audio_finish_on_pause: default_allow_audio_finish_on_pause(),
            pause_debounce_threshold: default_pause_debounce_threshold(),
            rapid_pause_threshold: default_rapid_pause_threshold(),
            enable_audio_system_recovery: true,
            ui_scale: 1.0,
            toast_visibility: ToastVisibility::default(),
        }
    }
}

impl Config {
    pub fn load() -> Result<Self> {
        let mut path = PathBuf::from(".zcb/");
        log::debug!("creating directory {path:?}");
        std::fs::create_dir_all(&path)?;
        path.push("config.json");

        // try to read config
        log::debug!("trying to read config at {path:?}");
        if let Ok(f) = std::fs::File::open(&path) {
            let config = serde_json::from_reader(f)
                .map_err(|e| log::error!("failed to deserialize config at {path:?}: {e}"));
            if let Ok(config) = config {
                log::debug!("successfully read config at {path:?}");
                return Ok(config);
            }
        }

        // failed to read config, write default config
        let config = Self::default();
        log::debug!("creating file {path:?}");
        let f = std::fs::File::create(&path)?;
        log::debug!("writing default config to {path:?}");
        serde_json::to_writer_pretty(f, &config)?;
        Ok(config)
    }

    pub fn save(&self) {
        let Ok(f) = std::fs::File::create(".zcb/config.json") else {
            log::error!("failed to create config.json!");
            return;
        };
        let _ = serde_json::to_writer_pretty(f, self)
            .map_err(|e| log::error!("failed to write config: {e}"))
            .map(|_| log::debug!("successfully saved config to \".zcb/config.json\""));
    }
}

#[derive(Default, Clone, Copy)]
struct ClickTime {
    time: f64,
    typ: ClickType,
}

#[derive(Default)]
pub struct ClickTimes {
    jump: [ClickTime; 2],  // 2 players
    left: [ClickTime; 2],  // 2 players
    right: [ClickTime; 2], // 2 players
}

impl ClickTimes {
    #[inline]
    fn set_time(&mut self, button: Button, player2: bool, t: ClickTime, decouple: bool) {
        match button {
            Button::Jump => self.jump[player2 as usize] = t,
            Button::Left => self.left[player2 as usize] = t,
            Button::Right => {
                // TODO:
                // WTF:  `(if decouple { self.right } else { self.left })[player2 as usize] = time``
                //       causes a Rust miscompilation if `decouple` is false???
                if decouple {
                    self.right[player2 as usize] = t;
                } else {
                    self.left[player2 as usize] = t;
                }
            }
        }
    }

    #[inline]
    const fn get_prev_time(&self, button: Button, player2: bool, decouple: bool) -> ClickTime {
        match button {
            Button::Jump => self.jump[player2 as usize],
            Button::Left => self.left[player2 as usize],
            Button::Right => {
                if decouple {
                    self.right[player2 as usize]
                } else {
                    self.left[player2 as usize]
                }
            }
        }
    }
}

pub struct Bot {
    pub conf: Config,
    pub prev_conf: Config,
    pub last_conf_save: Instant,
    pub mixer: Mixer,
    #[cfg(not(feature = "geode"))]
    pub playlayer: PlayLayer,
    pub prev_times: ClickTimes,
    pub is_loading_clickpack: Arc<AtomicBool>,
    pub prev_pitch: f64,
    pub prev_volume: f64,
    pub prev_spam_offset: f64,
    pub buffer_size_changed: bool,
    pub noise_sound: Option<SoundHandle>,
    pub clickpacks: Vec<String>,
    pub last_clickpack_reload: Instant,
    // pub system: *mut FMOD_SYSTEM,
    // pub channel: *mut FMOD_CHANNEL,
    pub env: Env,
    pub toasts: Arc<Mutex<Toasts>>,
    // pub fmod_noise_sound: *mut FMOD_CHANNEL,
    pub show_fmod_buffersize_warn: bool,
    pub startup_buffer_size: u32,
    pub is_in_level: bool,
    pub playlayer_time: f64,
    pub clickpack: Clickpack,
    pub first_launch_dialog_timeout: f32,
    pub level_start: Instant,
    // Enhanced timing for recording synchronization
    pub last_game_time: f64,
    pub last_real_time: Instant,
    pub time_offset: f64,
    pub pause_compensation: f64,
    pub time_smoothing_buffer: Vec<(f64, f64)>, // (game_time, real_time) pairs
    // Dual timing system for instant response
    pub input_timestamps: Vec<(Instant, f64)>, // (real_input_time, compensation) pairs
    pub last_input_time: Instant,
    pub audio_playback_time: f64,
    pub sync_time_cache: f64,
    pub clickpack_db: ClickpackDb,
    pub clickpack_db_open: bool,
    pub prev_scale_factor: f32,
    pub dead_timer: f32,
    pub dead_timer_limit: f32,
    pub devices: Arc<Mutex<Vec<String>>>,
    // Enhanced pause-aware audio management
    pub is_game_paused: bool,
    pub pause_detected_time: Instant,
    pub pause_state_debounce_timer: Instant,
    pub last_pause_state: bool,
    pub rapid_pause_resume_count: u32,
    pub audio_system_needs_reset: bool,
    pub pending_audio_actions: Vec<PendingAudioAction>,
}

impl Default for Bot {
    fn default() -> Self {
        let conf = Config::load().unwrap_or_default().fixup();
        let startup_buffer_size = conf.buffer_size;
        let now = Instant::now();
        Self {
            conf: conf.clone(),
            prev_conf: conf,
            last_conf_save: now,
            mixer: Mixer::new(),
            #[cfg(not(feature = "geode"))]
            playlayer: PlayLayer::NULL,
            prev_times: ClickTimes::default(),
            is_loading_clickpack: Arc::new(AtomicBool::new(false)),
            prev_pitch: f64::NAN,
            prev_volume: f64::NAN,
            prev_spam_offset: f64::NAN,
            buffer_size_changed: false,
            noise_sound: None,
            clickpacks: vec![],
            last_clickpack_reload: now,
            // system: std::ptr::null_mut(),
            // channel: std::ptr::null_mut(),
            env: Env::load(),
            toasts: Arc::new(Mutex::new(Toasts::new())),
            // fmod_noise_sound: std::ptr::null_mut(),
            show_fmod_buffersize_warn: false,
            startup_buffer_size,
            is_in_level: false,
            playlayer_time: 0.0,
            clickpack: Clickpack::default(),
            first_launch_dialog_timeout: 3.0,
            level_start: now,
            // Initialize enhanced timing fields
            last_game_time: 0.0,
            last_real_time: now,
            time_offset: 0.0,
            pause_compensation: 0.0,
            time_smoothing_buffer: Vec::with_capacity(10),
            // Initialize dual timing fields
            input_timestamps: Vec::with_capacity(20),
            last_input_time: now,
            audio_playback_time: 0.0,
            sync_time_cache: 0.0,
            clickpack_db: ClickpackDb::default(),
            clickpack_db_open: false,
            prev_scale_factor: 1.0,
            dead_timer: f32::NAN,
            dead_timer_limit: 0.0,
            devices: Arc::new(Mutex::new(vec![])),
            // Initialize enhanced pause-aware audio management
            is_game_paused: false,
            pause_detected_time: now,
            pause_state_debounce_timer: now,
            last_pause_state: false,
            rapid_pause_resume_count: 0,
            audio_system_needs_reset: false,
            pending_audio_actions: Vec::new(),
        }
    }
}

fn help_text<R>(ui: &mut egui::Ui, help: &str, add_contents: impl FnOnce(&mut egui::Ui) -> R) {
    if help.is_empty() {
        add_contents(ui); // don't show help icon if there's no help text
        return;
    }
    ui.horizontal(|ui| {
        add_contents(ui);
        ui.add_enabled_ui(false, |ui| ui.label("(?)").on_disabled_hover_text(help));
    });
}

/// Value is always min clamped with 1.
fn u32_edit_field_min1(ui: &mut egui::Ui, value: &mut u32) -> egui::Response {
    let mut tmp_value = format!("{value}");
    let res = ui.text_edit_singleline(&mut tmp_value);
    if let Ok(result) = tmp_value.parse::<u32>() {
        *value = result.max(1);
    }
    res
}

/*
#[inline]
fn gd_audio_pitch() -> f32 {
    let mut pitch = 1.0f32;
    unsafe {
        let _ = FMOD_Channel_GetPitch(
            FMODAudioEngine::shared().current_sound_channel(),
            &mut pitch,
        );
    };
    pitch
}
*/

fn show_error_dialog(modal: Arc<Mutex<Modal>>, title: &str, body: &str) {
    log::error!("{title}: {body}");
    modal
        .lock()
        .dialog()
        .with_title(title)
        .with_body(utils::capitalize_first_letter(body))
        .with_icon(Icon::Error)
        .open();
}

fn drag_value<Num: emath::Numeric>(
    ui: &mut egui::Ui,
    value: &mut Num,
    text: impl Into<String>,
    clamp_range: RangeInclusive<Num>,
    help: &str,
) -> egui::Response {
    let mut resp = None;
    help_text(ui, help, |ui| {
        resp = Some(
            ui.add(
                DragValue::new(value)
                    .clamp_range(clamp_range.clone())
                    .speed(0.01),
            ),
        );
        ui.label(
            if resp.as_ref().unwrap().dragged()
                && (clamp_range.start() == value || clamp_range.end() == value)
            {
                RichText::new(text).color(Color32::LIGHT_RED)
            } else {
                RichText::new(text)
            },
        );
    });
    resp.unwrap()
}

const USER_AGENT: &str = "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Ubuntu Chromium/37.0.2062.94 Chrome/37.0.2062.94 Safari/537.36";

fn ureq_agent() -> ureq::Agent {
    ureq::AgentBuilder::new()
        .timeout_read(Duration::from_secs(15))
        .timeout_write(Duration::from_secs(15))
        .user_agent(USER_AGENT)
        .build()
}

fn ureq_get(url: &str) -> Result<Vec<u8>, String> {
    let mut buf = Vec::new();
    ureq_agent()
        .get(url)
        .call()
        .map_err(|e| e.to_string())?
        .into_reader()
        .read_to_end(&mut buf)
        .map_err(|_| "failed to read body".to_string())?;
    Ok(buf)
}

impl Bot {
    fn maybe_init_kittyaudio(&mut self) {
        if self.conf.use_fmod {
            return;
        }
        log::debug!("starting kittyaudio playback thread");
        self.mixer = Mixer::new();
        let device = self.get_device();

        self.mixer.init_ex(
            device,
            StreamSettings {
                buffer_size: Some(self.conf.buffer_size),
                ..Default::default()
            },
        );
    }

    pub unsafe fn init_fmod(&mut self) -> Result<()> {
        /*
        const SYSTEM_SAMPLERATE: i32 = 48_000;
        log::info!("initializing fmod system");
        if !self.system.is_null() {
            self.release_fmod();
        }

        FMOD_System_Create(&mut self.system, FMOD_VERSION).fmod_result()?;
        let extra_driver_data = FMODAudioEngine::shared().extra_driver_data();

        FMOD_System_SetSoftwareFormat(self.system, SYSTEM_SAMPLERATE, FMOD_SPEAKERMODE_STEREO, 0)
            .fmod_result()?;

        // set buffer size
        /*
        FMOD_System_SetStreamBufferSize(self.system, self.conf.buffer_size, FMOD_TIMEUNIT_PCM)
            .fmod_result()?;

        let mut numbuffers = 0i32;
        let mut bufferlength = 0u32;
        FMOD_System_GetDSPBufferSize(self.system, &mut bufferlength, &mut numbuffers)
            .fmod_result()?;
        log::info!(
            "FMOD_System_GetDSPBufferSize: bufferlength: {bufferlength}, numbuffers: {numbuffers}"
        );
        FMOD_System_SetDSPBufferSize(self.system, self.conf.buffer_size, numbuffers)
            .fmod_result()?;
        */

        // init system
        self.fmod_apply_buffer_size()?;
        FMOD_System_Init(self.system, 2048, FMOD_INIT_NORMAL, extra_driver_data).fmod_result()?;

        log::info!("successfully initialized fmod system, samplerate: {SYSTEM_SAMPLERATE}");
        */
        Ok(())
    }

    //fn fmod_apply_buffer_size(&self) -> Result<()> {
    //    /*
    //    unsafe {
    //        FMOD_System_SetStreamBufferSize(self.system, self.conf.buffer_size, FMOD_TIMEUNIT_PCM)
    //            .fmod_result()?;
    //
    //        let mut numbuffers = 0i32;
    //        let mut bufferlength = 0u32;
    //        FMOD_System_GetDSPBufferSize(self.system, &mut bufferlength, &mut numbuffers)
    //            .fmod_result()?;
    //        log::info!(
    //            "FMOD_System_GetDSPBufferSize: bufferlength: {bufferlength}, numbuffers: {numbuffers}"
    //        );
    //        FMOD_System_SetDSPBufferSize(self.system, self.conf.buffer_size, numbuffers)
    //            .fmod_result()?;
    //    }
    //    */
    //    Ok(())
    //}

    pub fn release_fmod(&mut self) {
        /*
        let _ = unsafe {
            FMOD_System_Release(self.system)
                .fmod_result()
                .map_err(|e| log::error!("failed to release fmod system: {e}"))
        };
        self.system = std::ptr::null_mut();
        */
    }

    pub fn init(&mut self) {
        {
            let devices_arc = self.devices.clone();
            std::thread::spawn(move || {
                let mut prev_devices = vec![];
                loop {
                    if unsafe { BOT.conf.use_fmod } {
                        continue;
                    }
                    if let Ok(devices) = kittyaudio::device_names() {
                        // only lock when device lists do not match
                        if devices != prev_devices {
                            log::trace!("updated device list: {devices:?}");
                            *devices_arc.lock() = devices.clone();
                            prev_devices = devices;
                        }
                    }
                    std::thread::sleep(Duration::from_secs(4));
                }
            });
        }

        // init audio playback
        if !self.conf.use_fmod {
            self.maybe_init_kittyaudio();
        }
        unsafe {
            let _ = self
                .init_fmod()
                .map_err(|e| log::error!("failed to init fmod: {e}"));
        };

        // reload clickpacks
        let _ = self
            .reload_clickpacks()
            .map_err(|e| log::error!("failed to reload clickpacks: {e}"));

        // preload clickpack
        self.preload_clickpack();

        // init game hooks
        #[cfg(not(feature = "geode"))]
        {
            log::debug!("initializing hooks");
            unsafe { hooks::init_hooks().unwrap() };
        }
    }

    fn preload_clickpack(&mut self) {
        log::info!("preloading clickpack, order: {:?}", self.env.clickpack_ord);
        use std::thread::JoinHandle;

        let preload_clickpack = |path: PathBuf,
                                 toasts: Arc<Mutex<Toasts>>,
                                 join_handle: Option<JoinHandle<()>>,
                                 load_for: LoadClickpackFor|
         -> JoinHandle<()> {
            // wait for the last spawned thread finish first; order is important here
            // (clickpack loading is not threadsafe)
            if let Some(handle) = join_handle {
                log::info!("waiting for other preload thread to finish");
                handle.join().unwrap();
                log::info!("other preload thread finished, continuing");
            }

            let is_loading_clickpack = self.is_loading_clickpack.clone();
            std::thread::spawn(move || {
                Self::load_clickpack_thread(
                    |e| {
                        toasts
                            .lock()
                            .add(Toast::error(format!("Failed to preload clickpack: {e}")));
                    },
                    &path,
                    is_loading_clickpack,
                    load_for,
                )
            })
        };

        let mut prev_join_handle: Option<JoinHandle<()>> = None;
        for (clickpack_env, load_for) in &self.env.clickpack_ord {
            log::info!("preloading clickpack {clickpack_env:?} for {load_for:?}");
            match clickpack_env {
                ClickpackEnv::Name(name) => {
                    let mut found = false;
                    for dirname in &self.clickpacks {
                        if dirname == name {
                            prev_join_handle = Some(preload_clickpack(
                                PathBuf::from(".zcb").join("clickpacks").join(dirname),
                                self.toasts.clone(),
                                prev_join_handle,
                                *load_for,
                            ));
                            found = true;
                            break;
                        }
                    }
                    if !found {
                        self.toasts
                            .lock()
                            .add(Toast::error(format!("Clickpack \"{name}\" not found")));
                    }
                }
                ClickpackEnv::Path(path) => {
                    prev_join_handle = Some(preload_clickpack(
                        path.clone(),
                        self.toasts.clone(),
                        prev_join_handle,
                        *load_for,
                    ));
                }
                ClickpackEnv::None => log::info!("env.json doesn't specify a clickpack"),
            }
        }
        if let Some(handle) = prev_join_handle {
            std::thread::spawn(|| {
                handle.join().unwrap();
                log::info!("all clickpacks preloaded, playing noise (if any)");
                unsafe { BOT.play_noise() };
            });
        }
    }

    fn get_pitch(&self) -> f64 {
        if self.conf.pitch_enabled {
            utils::f64_range(self.conf.pitch.from..=self.conf.pitch.to)
        } else {
            1.0
        }
    }

    #[allow(unused_variables)]
    pub fn on_init(&mut self, playlayer: usize) {
        #[cfg(not(feature = "geode"))]
        {
            self.playlayer.addr = playlayer;
        }

        self.prev_times = ClickTimes::default();
        self.prev_pitch = 0.0;
        self.prev_volume = self.conf.volume_settings.global_volume;
        self.prev_spam_offset = 0.0;
        self.is_in_level = true;
        let now = Instant::now();
        self.level_start = now;
        self.dead_timer = f32::NAN;

        // Initialize enhanced timing system
        self.last_game_time = 0.0;
        self.last_real_time = now;
        self.time_offset = 0.0;
        self.pause_compensation = 0.0;
        self.time_smoothing_buffer.clear();

        // Initialize dual timing system
        self.input_timestamps.clear();
        self.last_input_time = now;
        self.audio_playback_time = 0.0;
        self.sync_time_cache = 0.0;
    }

    pub fn on_reset(&mut self) {
        let now = Instant::now();
        self.level_start = now;
        self.prev_times = ClickTimes::default();
        self.dead_timer = f32::NAN;

        // Reset enhanced timing system for level restart
        self.last_game_time = 0.0;
        self.last_real_time = now;
        self.time_offset = 0.0;
        self.pause_compensation = 0.0;
        self.time_smoothing_buffer.clear();

        // Reset dual timing system
        self.input_timestamps.clear();
        self.last_input_time = now;
        self.audio_playback_time = 0.0;
        self.sync_time_cache = 0.0;

        // Reset enhanced pause-aware audio management
        self.is_game_paused = false;
        self.pause_detected_time = now;
        self.pause_state_debounce_timer = now;
        self.last_pause_state = false;
        self.rapid_pause_resume_count = 0;
        self.audio_system_needs_reset = false;
        self.pending_audio_actions.clear();
    }

    pub fn on_exit(&mut self) {
        self.on_init(0);
        self.is_in_level = false;
        self.dead_timer = f32::NAN;
    }

    unsafe fn release_buttons(&mut self) {
        log::info!("releasing buttons on death");
        for (button, t) in [
            (Button::Jump, self.prev_times.jump),
            (Button::Left, self.prev_times.left),
            (Button::Right, self.prev_times.right),
        ] {
            for (player, time) in t.iter().enumerate() {
                if time.typ.is_click() && time.time != 0.0 {
                    self.on_action(button, player == 1, false);
                }
            }
        }
    }

    pub unsafe fn on_death(&mut self) {
        if !self.conf.release_buttons_on_death {
            return;
        }

        let mut release_delay = self.conf.death_release_delay;
        let offset = self.conf.death_release_delay_offset;

        // release all buttons that are still pressed (or do that in the future)
        if release_delay == 0.0 && offset == 0.0 {
            self.release_buttons();
        } else {
            if offset != 0.0 {
                if self.conf.death_release_delay_neg {
                    release_delay += utils::f64_range(-offset..=offset);
                } else {
                    release_delay += utils::f64_range(0.0..=offset);
                }
            }
            if release_delay <= 0.0 {
                self.release_buttons();
                return;
            }
            self.dead_timer_limit = release_delay as f32;
            self.dead_timer = 0.0;
        }
    }

    pub unsafe fn on_update(&mut self, dt: f32) {
        // Update enhanced timing state for better recording synchronization
        self.update_timing_state();

        // Check and recover audio system if needed
        self.check_and_recover_audio_system();

        // Clean up old pending audio actions (older than 500ms)
        let now = Instant::now();
        self.pending_audio_actions.retain(|action| {
            match action {
                PendingAudioAction::Play { timestamp, .. } => {
                    timestamp.elapsed().as_millis() < 500
                }
                _ => true, // Keep non-play actions
            }
        });

        // Reset rapid pause counter if enough time has passed without rapid changes
        if self.pause_state_debounce_timer.elapsed().as_secs_f64() > 1.0 {
            self.rapid_pause_resume_count = 0;
        }

        if !self.dead_timer.is_nan() {
            self.dead_timer += dt;
            if self.dead_timer >= self.dead_timer_limit {
                self.dead_timer = f32::NAN;
                self.release_buttons();
            }
        }
    }

    #[allow(unused_mut)]
    pub unsafe fn on_action(&mut self, button: Button, mut player2: bool, push: bool) {
        if self.clickpack.num_sounds == 0 || !self.is_in_level || !self.conf.enabled {
            return;
        }

        // Enhanced pause handling with action queuing
        if self.is_game_paused && self.conf.allow_audio_finish_on_pause {
            if self.conf.enable_audio_system_recovery {
                // Queue the action for later processing when resumed
                self.pending_audio_actions.push(PendingAudioAction::Play {
                    button,
                    player2,
                    push,
                    timestamp: Instant::now(),
                });
                log::trace!("Queued audio action during pause for later processing");
            } else {
                // Original behavior: skip new audio during pause
                log::trace!("Skipping new audio during pause - allowing current sounds to finish");
            }
            return;
        }

        // Check if audio system needs recovery
        self.check_and_recover_audio_system();

        // Record input event for instant response tracking
        self.record_input_event();

        #[cfg(not(feature = "geode"))]
        if player2 && !self.playlayer.is_null()
        /* FIXME(2.206): && !self.playlayer.level_settings().is_2player() */
        {
            player2 = self.conf.force_player2_sounds;
        }
        #[cfg(not(feature = "geode"))]
        if !self.playlayer.is_null() {
            return;
        }
        if button.is_platformer()
            && !self.conf.force_playing_platformer
            && !self.clickpack.has_platformer_sounds
        {
            return;
        }

        // Dual timing system: separate audio and sync timing
        let audio_time = self.get_predictive_audio_time();
        let sync_time = self.sync_time();

        if sync_time == 0.0 {
            return;
        }

        // Use sync time for timing calculations (accuracy)
        let prev_time =
            self.prev_times
                .get_prev_time(button, player2, self.conf.decouple_platformer);
        if prev_time.typ.is_click() && push {
            return;
        }
        let dt = (sync_time - prev_time.time).abs();
        let click_type = ClickType::from_time(push, dt, &self.conf.timings);
        if self.conf.ignored_click_types.is_ignored(click_type) {
            return;
        }
        let use_fmod = self.conf.use_fmod;

        // get click
        let mut click = self
            .clickpack
            .get_random_click(click_type, player2, button)
            .sound
            .clone();
        let pitch = self.get_pitch() * self.conf.click_speedhack;
        // if self.conf.sync_speed_with_game {
        //     pitch *= gd_audio_pitch() as f64;
        // }
        if !use_fmod {
            click.set_playback_rate(PlaybackRate::Factor(pitch));
        }

        // compute & change volume
        {
            let vol = &self.conf.volume_settings;
            let mut volume = 1.0;
            if vol.volume_var != 0.0 {
                volume += utils::f64_range(-vol.volume_var..=vol.volume_var);
            }

            // calculate spam volume change
            if (push || vol.change_releases_volume) && dt < vol.spam_time && vol.enabled {
                let offset = (vol.spam_time - dt) * vol.spam_vol_offset_factor;
                self.prev_spam_offset = offset;
                volume -= offset.min(vol.max_spam_vol_offset);
            } else {
                self.prev_spam_offset = 0.0;
            }

            if button.is_platformer() {
                volume *= vol.platformer_volume_factor;
            }

            // multiply by global volume after all of the changes
            volume *= vol.global_volume;

            if !use_fmod {
                // blehh
                click.set_volume(volume as f32);
            }
            self.prev_volume = volume;
        }

        // stop all playing sounds (acb behaviour)
        // But respect pause-aware audio settings
        if !use_fmod
            && self.conf.cut_sounds
            && (!click_type.is_release() || self.conf.cut_by_releases)
            && !(self.is_game_paused && self.conf.allow_audio_finish_on_pause)
        {
            for sound in &self.mixer.renderer.guard().sounds {
                // check if this is the noise sound, we don't want to stop it
                let sound_len = sound.guard().frames.len();
                if let Some(noise_sound) = &self.noise_sound {
                    if noise_sound.guard().frames.len() == sound_len {
                        continue;
                    }
                }

                // kis!!
                sound.seek_to_end();
            }
        }
        // FIXME: temporary 2.2 fix
        self.mixer.play(click);
        /*
        if !use_fmod {
            self.mixer.play(click);
        } else {
            /*
            unsafe {
                FMOD_System_PlaySound(
                    self.system,
                    click.fmod_sound,
                    std::ptr::null_mut(),
                    0,
                    &mut self.channel,
                );
                FMOD_Channel_SetPitch(self.channel, pitch as f32);
                FMOD_Channel_SetVolume(self.channel, self.prev_volume);
                FMOD_System_Update(self.system);
            }
            */
        }
        */
        // Store timing information using sync time for accuracy
        self.prev_times.set_time(
            button,
            player2,
            ClickTime {
                time: sync_time, // Use sync time for timing calculations
                typ: click_type,
            },
            self.conf.decouple_platformer,
        );
        self.prev_pitch = pitch;

        // Cache audio playback time for diagnostics
        self.audio_playback_time = audio_time;
    }

    /// Get timing for audio playback (prioritizes responsiveness)
    #[inline]
    fn audio_time(&mut self) -> f64 {
        match self.conf.timing_mode {
            TimingMode::Responsive => {
                // Always use real-time for maximum responsiveness
                self.level_start.elapsed().as_secs_f64() + self.conf.input_latency_compensation
            }
            TimingMode::Synchronized => {
                // Use synchronized time for perfect recording sync
                self.sync_time()
            }
            TimingMode::Hybrid => {
                // Use instant response if enabled, otherwise synchronized
                if self.conf.instant_audio_response {
                    self.level_start.elapsed().as_secs_f64() + self.conf.input_latency_compensation
                } else {
                    self.sync_time()
                }
            }
        }
    }

    /// Get timing for synchronization calculations (prioritizes accuracy)
    #[inline]
    fn sync_time(&mut self) -> f64 {
        if !self.conf.use_ingame_time {
            return self.level_start.elapsed().as_secs_f64();
        }

        // Get raw game time
        let raw_game_time = {
            #[cfg(feature = "geode")]
            {
                if self.playlayer_time != 0.0 {
                    self.playlayer_time
                } else {
                    return self.level_start.elapsed().as_secs_f64();
                }
            }
            #[cfg(not(feature = "geode"))]
            {
                if !self.playlayer.is_null() {
                    self.playlayer.time()
                } else {
                    return self.level_start.elapsed().as_secs_f64();
                }
            }
        };

        if !self.conf.enhanced_recording_sync {
            return raw_game_time;
        }

        // Enhanced timing for recording synchronization
        self.get_synchronized_time(raw_game_time)
    }

    /// Legacy time method for backward compatibility
    #[inline]
    fn time(&mut self) -> f64 {
        // Use sync time for timing calculations to maintain accuracy
        self.sync_time()
    }

    /// Enhanced timing calculation for better recording synchronization
    fn get_synchronized_time(&mut self, raw_game_time: f64) -> f64 {
        let current_real_time = Instant::now();
        let real_elapsed = current_real_time.duration_since(self.last_real_time).as_secs_f64();

        // Detect potential pause/resume by checking for large time jumps
        let game_time_delta = raw_game_time - self.last_game_time;
        let is_paused = real_elapsed > self.conf.pause_detection_threshold && game_time_delta < real_elapsed * 0.5;

        // Enhanced pause state management with debouncing
        self.update_pause_state_with_debouncing(is_paused, current_real_time);

        if is_paused {
            // During pause, maintain the last known synchronized time
            return self.last_game_time + self.time_offset;
        }

        // Calculate time drift between game time and real time
        let expected_real_time = self.level_start.elapsed().as_secs_f64();
        let time_drift = raw_game_time - expected_real_time;

        // Apply smoothing to reduce timing jitter during recording
        let smoothed_time = if !self.time_smoothing_buffer.is_empty() {
            let avg_drift = self.time_smoothing_buffer.iter()
                .map(|(_, drift)| *drift)
                .sum::<f64>() / self.time_smoothing_buffer.len() as f64;

            let smoothing = self.conf.time_smoothing_factor;
            raw_game_time + (avg_drift * smoothing) + (time_drift * (1.0 - smoothing))
        } else {
            raw_game_time
        };

        smoothed_time + self.pause_compensation
    }

    /// Update timing state for enhanced synchronization
    /// This should be called regularly to maintain accurate timing data
    fn update_timing_state(&mut self) {
        if !self.conf.use_ingame_time || !self.conf.enhanced_recording_sync {
            // Even if enhanced sync is disabled, we still need to detect pauses for audio management
            self.update_pause_state_basic();
            return;
        }

        let current_real_time = Instant::now();
        let raw_game_time = {
            #[cfg(feature = "geode")]
            {
                self.playlayer_time
            }
            #[cfg(not(feature = "geode"))]
            {
                if !self.playlayer.is_null() {
                    self.playlayer.time()
                } else {
                    return;
                }
            }
        };

        // Update smoothing buffer with recent timing data
        let real_elapsed = current_real_time.duration_since(self.level_start).as_secs_f64();
        let time_drift = raw_game_time - real_elapsed;

        self.time_smoothing_buffer.push((raw_game_time, time_drift));

        // Keep buffer size manageable (last 10 samples for smoothing)
        if self.time_smoothing_buffer.len() > 10 {
            self.time_smoothing_buffer.remove(0);
        }

        // Detect and compensate for pauses
        let real_delta = current_real_time.duration_since(self.last_real_time).as_secs_f64();
        let game_delta = raw_game_time - self.last_game_time;

        let is_paused = real_delta > self.conf.pause_detection_threshold && game_delta < real_delta * 0.5;

        // Enhanced pause state management with debouncing (for enhanced timing system)
        self.update_pause_state_with_debouncing(is_paused, current_real_time);

        if is_paused {
            // Game was likely paused, accumulate pause compensation
            self.pause_compensation += real_delta - game_delta;
        }

        // Update state for next iteration
        self.last_game_time = raw_game_time;
        self.last_real_time = current_real_time;
    }

    /// Enhanced pause state management with debouncing and rapid change detection
    fn update_pause_state_with_debouncing(&mut self, is_paused: bool, current_time: Instant) {
        let debounce_elapsed = current_time.duration_since(self.pause_state_debounce_timer).as_secs_f64();

        // Check if we should apply debouncing
        let should_debounce = debounce_elapsed < self.conf.pause_debounce_threshold;

        // Detect rapid pause/resume cycles
        if is_paused != self.last_pause_state && !should_debounce {
            self.rapid_pause_resume_count += 1;
            self.pause_state_debounce_timer = current_time;

            // Check if we've exceeded the rapid pause threshold
            if self.rapid_pause_resume_count >= self.conf.rapid_pause_threshold {
                log::warn!("Rapid pause/resume cycles detected ({}), marking audio system for reset",
                          self.rapid_pause_resume_count);
                self.audio_system_needs_reset = true;
                self.rapid_pause_resume_count = 0; // Reset counter
            }
        }

        // Only update pause state if not debouncing or if it's been stable
        if !should_debounce || is_paused == self.last_pause_state {
            if is_paused && !self.is_game_paused {
                // Game just paused
                self.is_game_paused = true;
                self.pause_detected_time = current_time;
                log::debug!("Game pause detected - allowing current audio to finish");

                // If audio system recovery is enabled, handle pause more gracefully
                if self.conf.enable_audio_system_recovery && self.conf.allow_audio_finish_on_pause {
                    // Don't immediately stop sounds, let them finish naturally
                    log::debug!("Allowing current audio to finish during pause");
                }
            } else if !is_paused && self.is_game_paused {
                // Game just resumed
                self.is_game_paused = false;
                log::debug!("Game resumed - normal audio behavior restored");

                // Process any pending audio actions that were queued during pause
                if self.conf.enable_audio_system_recovery {
                    self.process_pending_audio_actions();
                }
            }

            self.last_pause_state = is_paused;
        }
    }

    /// Basic pause detection for standard timing system
    /// Used when enhanced recording sync is disabled but pause-aware audio is still needed
    fn update_pause_state_basic(&mut self) {
        if !self.conf.use_ingame_time || !self.conf.allow_audio_finish_on_pause {
            return;
        }

        let current_real_time = Instant::now();
        let raw_game_time = {
            #[cfg(feature = "geode")]
            {
                self.playlayer_time
            }
            #[cfg(not(feature = "geode"))]
            {
                if !self.playlayer.is_null() {
                    self.playlayer.time()
                } else {
                    return;
                }
            }
        };

        // Simple pause detection without the full enhanced timing system
        let real_delta = current_real_time.duration_since(self.last_real_time).as_secs_f64();
        let game_delta = raw_game_time - self.last_game_time;

        let is_paused = real_delta > self.conf.pause_detection_threshold && game_delta < real_delta * 0.5;

        // Enhanced pause state management with debouncing (for basic timing system)
        self.update_pause_state_with_debouncing(is_paused, current_real_time);

        // Update state for next iteration
        self.last_game_time = raw_game_time;
        self.last_real_time = current_real_time;
    }

    /// Record input timestamp for instant response tracking
    fn record_input_event(&mut self) {
        let now = Instant::now();
        let compensation = self.calculate_input_compensation();

        self.input_timestamps.push((now, compensation));
        self.last_input_time = now;

        // Keep buffer size manageable (last 20 inputs for analysis)
        if self.input_timestamps.len() > 20 {
            self.input_timestamps.remove(0);
        }
    }

    /// Calculate input latency compensation based on recent input patterns
    fn calculate_input_compensation(&self) -> f64 {
        if self.input_timestamps.is_empty() {
            return self.conf.input_latency_compensation;
        }

        // Analyze recent input timing patterns to predict optimal compensation
        let recent_inputs = self.input_timestamps.iter()
            .rev()
            .take(5)
            .collect::<Vec<_>>();

        if recent_inputs.len() < 2 {
            return self.conf.input_latency_compensation;
        }

        // Calculate average time between recent inputs
        let mut total_delta = 0.0;
        for i in 1..recent_inputs.len() {
            let delta = recent_inputs[i-1].0.duration_since(recent_inputs[i].0).as_secs_f64();
            total_delta += delta;
        }
        let avg_input_rate = total_delta / (recent_inputs.len() - 1) as f64;

        // Adjust compensation based on input rate (faster inputs need less compensation)
        let base_compensation = self.conf.input_latency_compensation;
        let rate_factor = (avg_input_rate * 10.0).min(1.0); // Scale factor based on input rate

        base_compensation * rate_factor
    }

    /// Get predictive timing for immediate audio response
    fn get_predictive_audio_time(&mut self) -> f64 {
        let base_time = self.audio_time();

        if !self.conf.instant_audio_response {
            return base_time;
        }

        // Apply predictive compensation for ultra-low latency
        let compensation = self.calculate_input_compensation();
        base_time - compensation // Subtract to play audio earlier
    }

    /// Get timing diagnostics for debugging and verification
    pub fn get_timing_diagnostics(&self) -> String {
        let real_elapsed = self.level_start.elapsed().as_secs_f64();
        let game_time = {
            #[cfg(feature = "geode")]
            {
                self.playlayer_time
            }
            #[cfg(not(feature = "geode"))]
            {
                if !self.playlayer.is_null() {
                    self.playlayer.time()
                } else {
                    0.0
                }
            }
        };

        let timing_mode_str = self.conf.timing_mode.text();
        let input_compensation = self.conf.input_latency_compensation;
        let last_input_age = self.last_input_time.elapsed().as_secs_f64();

        if !self.conf.use_ingame_time {
            return format!(
                "Real-time mode:\n\
                Timing Mode: {}\n\
                Real Time: {:.3}s\n\
                Audio Time: {:.3}s\n\
                Input Compensation: {:.3}s\n\
                Last Input: {:.3}s ago\n\
                Instant Response: {}\n\
                Pause-Aware Audio: {}\n\
                Game Paused: {}",
                timing_mode_str,
                real_elapsed,
                self.audio_playback_time,
                input_compensation,
                last_input_age,
                self.conf.instant_audio_response,
                self.conf.allow_audio_finish_on_pause,
                self.is_game_paused
            );
        }

        if !self.conf.enhanced_recording_sync {
            return format!(
                "Basic in-game time mode:\n\
                Timing Mode: {}\n\
                Game Time: {:.3}s\n\
                Real Time: {:.3}s\n\
                Audio Time: {:.3}s\n\
                Drift: {:.3}s\n\
                Input Compensation: {:.3}s\n\
                Last Input: {:.3}s ago\n\
                Instant Response: {}\n\
                Pause-Aware Audio: {}\n\
                Game Paused: {}",
                timing_mode_str,
                game_time,
                real_elapsed,
                self.audio_playback_time,
                game_time - real_elapsed,
                input_compensation,
                last_input_age,
                self.conf.instant_audio_response,
                self.conf.allow_audio_finish_on_pause,
                self.is_game_paused
            );
        }

        let avg_drift = if !self.time_smoothing_buffer.is_empty() {
            self.time_smoothing_buffer.iter()
                .map(|(_, drift)| *drift)
                .sum::<f64>() / self.time_smoothing_buffer.len() as f64
        } else {
            0.0
        };

        format!(
            "Dual Timing System (Enhanced):\n\
            Timing Mode: {}\n\
            Game Time: {:.3}s\n\
            Real Time: {:.3}s\n\
            Audio Time: {:.3}s\n\
            Sync Time: {:.3}s\n\
            Raw Drift: {:.3}s\n\
            Avg Drift: {:.3}s\n\
            Pause Compensation: {:.3}s\n\
            Input Compensation: {:.3}s\n\
            Last Input: {:.3}s ago\n\
            Smoothing Factor: {:.1}%\n\
            Buffer Size: {}/10\n\
            Input Buffer: {}/20\n\
            Instant Response: {}\n\
            Pause-Aware Audio: {}\n\
            Game Paused: {}",
            timing_mode_str,
            game_time,
            real_elapsed,
            self.audio_playback_time,
            self.sync_time_cache,
            game_time - real_elapsed,
            avg_drift,
            self.pause_compensation,
            input_compensation,
            last_input_age,
            self.conf.time_smoothing_factor * 100.0,
            self.time_smoothing_buffer.len(),
            self.input_timestamps.len(),
            self.conf.instant_audio_response,
            self.conf.allow_audio_finish_on_pause,
            self.is_game_paused
        )
    }

    fn open_clickbot_toggle_toast(&self) {
        self.toasts.lock().add(Toast::info(if self.conf.enabled {
            "Enabled clickbot"
        } else {
            "Disabled clickbot"
        }));
    }

    fn reload_clickpacks(&mut self) -> Result<()> {
        let path = Path::new(".zcb/clickpacks");
        std::fs::create_dir_all(path)?;
        let dir = path.read_dir()?;
        let prev_clickpacks = std::mem::take(&mut self.clickpacks);
        for entry in dir {
            let entry = entry?;
            let path = entry.path();
            if path.is_dir() {
                let name = path.file_name().unwrap().to_string_lossy().to_string();
                self.clickpack_db.mark_downloaded(&name, path, true);
                self.clickpacks.push(name);
            }
        }
        for prev in &prev_clickpacks {
            if !self.clickpacks.contains(prev) {
                self.clickpack_db
                    .mark_downloaded(prev, path.to_path_buf(), false);
            }
        }
        Ok(())
    }

    pub fn draw_ui(&mut self, ctx: &egui::Context) {
        // process hotkeys
        let wants_keyboard = ctx.wants_keyboard_input();
        let (toggle_menu, toggle_bot, toggle_noise) = ctx.input_mut(|i| {
            // for some reason it deadlocks when i put `ctx.wants_keyboard_input()` here?
            if wants_keyboard {
                (false, false, false)
            } else {
                (
                    self.conf.shortcuts.toggle_menu.pressed(i),
                    self.conf.shortcuts.toggle_bot.pressed(i),
                    self.conf.shortcuts.toggle_noise.pressed(i),
                )
            }
        });
        if toggle_menu {
            self.conf.hidden = !self.conf.hidden;
        }
        if toggle_bot {
            self.conf.enabled = !self.conf.enabled;
        }
        if toggle_noise {
            self.conf.play_noise = !self.conf.play_noise;
            self.play_noise();
        }

        // autosave config
        if self.conf != self.prev_conf && self.last_conf_save.elapsed() > Duration::from_secs(5) {
            self.last_conf_save = Instant::now();
            self.conf.save();
            self.prev_conf = self.conf.clone();
        }

        // change ui scale if needed
        ctx.set_zoom_factor(
            self.conf
                .ui_scale
                .clamp(*UI_SCALE_RANGE.start(), *UI_SCALE_RANGE.end()),
        );

        // dialog on first launch
        if self.env.is_first_launch {
            let modal = Modal::new(ctx, "first_launch_dialog");
            modal.show(|ui| {
                modal.title(ui, "Welcome to ZCB Live!");
                modal.body_and_icon(
                    ui,
                    "This seems to be your first time using ZCB Live.\n\
                    • Press 1 to open the menu\n\
                    • Press 2 to toggle the clickbot\n\
                    • Explore ClickpackDB to download new clickpacks\n\
                    You can change the hotkeys in the Options section",
                    Icon::Info,
                );
                modal.buttons(ui, |ui| {
                    if self.first_launch_dialog_timeout > 0.0 {
                        ui.add_enabled_ui(false, |ui| {
                            let _ = ui
                                .button(format!("{:.0}…", self.first_launch_dialog_timeout.ceil()));
                        });
                        self.first_launch_dialog_timeout -= ctx.input(|i| i.unstable_dt);
                    } else if ui.button("Got it").clicked() {
                        self.env.is_first_launch = false;
                        self.env.save();
                        modal.close();
                    }
                    ui.hyperlink_to("Join the Discord server!", "https://discord.gg/BRVVVzxESu");
                });
            });
            modal.open();
        }

        // process toasts, even if not open
        if toggle_bot {
            self.open_clickbot_toggle_toast();
            self.play_noise();
        }
        if toggle_noise {
            self.open_noise_toggle_toast();
        }

        // don't draw and don't reload clickpacks if not open
        if self.conf.hidden {
            if matches!(self.conf.toast_visibility, ToastVisibility::AlwaysVisible) {
                self.toasts.lock().show(ctx); // but still draw toast queue
            }
            return;
        }

        // clickpack reloading
        if self.last_clickpack_reload.elapsed() > Duration::from_secs(5) {
            let _ = self
                .reload_clickpacks()
                .map_err(|e| log::error!("failed to reload clickpacks: {e}"));
            self.last_clickpack_reload = Instant::now();
        }

        // draw overlay
        let modal = Arc::new(Mutex::new(Modal::new(ctx, "global_modal")));

        // remove tooltip delay
        ctx.style_mut(|s| {
            s.interaction.tooltip_delay = 0.0;
            let shadow = Shadow {
                offset: [6.0, 8.0].into(),
                blur: 32.0,
                spread: 0.0,
                color: egui::Color32::from_black_alpha(120),
            };
            s.visuals.popup_shadow = shadow;
            s.visuals.window_shadow = shadow;
        });

        egui::Window::new("ZCB Live").show(ctx, |ui| {
            ui.horizontal(|ui| {
                ui.selectable_value(&mut self.conf.stage, Stage::Clickpack, "Clickpack");
                ui.selectable_value(&mut self.conf.stage, Stage::Audio, "Audio");
                ui.selectable_value(&mut self.conf.stage, Stage::Options, "Options");
                // ui.selectable_value(&mut self.conf.stage, Stage::Cheats, "Cheats");
            });
            ui.separator();

            egui::ScrollArea::both().show(ui, |ui| {
                match self.conf.stage {
                    Stage::Clickpack => self.show_clickpack_window(ui, modal.clone()),
                    Stage::Audio => {
                        if ui
                            .checkbox(&mut self.conf.enabled, "Enable clickbot")
                            .changed()
                        {
                            self.open_clickbot_toggle_toast();
                            self.play_noise();
                        }

                        // ui.separator();
                        ui.add_enabled_ui(self.conf.enabled, |ui| {
                            self.show_audio_window(ui);
                        });
                    }
                    Stage::Options => self.show_options_window(ui, ctx, modal.clone()),
                };
            });
        });

        // show clickpackdb, if open
        self.show_clickpackdb_window(ctx, modal.clone());

        // show modal & toast queue
        modal.lock().show_dialog();
        if matches!(
            self.conf.toast_visibility,
            ToastVisibility::AlwaysVisible | ToastVisibility::VisibleWhenOpen
        ) {
            self.toasts.lock().show(ctx);
        }
    }

    #[cfg(not(feature = "geode"))]
    pub fn maybe_alloc_console(&self) {
        if self.conf.show_console && unsafe { AllocConsole() }.is_ok() {
            use std::sync::Once;
            static INIT_ONCE: Once = Once::new();
            INIT_ONCE.call_once(|| {
                simple_logger::SimpleLogger::new()
                    .init()
                    .expect("failed to initialize simple_logger");
            });
        } else {
            unsafe {
                let _ = FreeConsole();
            }
        }
    }

    fn show_options_window(
        &mut self,
        ui: &mut egui::Ui,
        ctx: &egui::Context,
        modal: Arc<Mutex<Modal>>,
    ) {
        ui.collapsing("Shortcuts", |ui| {
            let mut show_shortcut = |shortcut: &mut Shortcut, id: &'static str, name: &str| {
                ui.horizontal(|ui| {
                    ui.vertical(|ui| ui.add(Keybind::new(shortcut, id).with_text(name)));
                    if *shortcut != Shortcut::NONE
                        && ui
                            .button("Clear")
                            .on_hover_text("Set the shortcut to none")
                            .clicked()
                    {
                        *shortcut = Shortcut::NONE;
                    }
                });
            };
            show_shortcut(
                &mut self.conf.shortcuts.toggle_menu,
                "toggle_menu_keybind",
                "Toggle menu",
            );
            show_shortcut(
                &mut self.conf.shortcuts.toggle_bot,
                "toggle_bot_keybind",
                "Toggle bot",
            );
            show_shortcut(
                &mut self.conf.shortcuts.toggle_noise,
                "toggle_noise_keybind",
                "Toggle noise",
            );
        });
        ui.collapsing("Configuration", |ui| {
            ui.horizontal(|ui| {
                let slider = ui.add(
                    egui::Slider::new(&mut self.conf.ui_scale, UI_SCALE_RANGE)
                        .step_by(0.001)
                        .text("UI Scale"),
                );
                if slider.clicked() {
                    self.prev_scale_factor = ctx.zoom_factor();
                }
                egui_gl_hook::set_changing_scale(
                    slider.changed()
                        || slider.clicked()
                        || slider.dragged()
                        || slider.drag_stopped()
                        || slider.has_focus(),
                    self.prev_scale_factor,
                );
                if self.conf.ui_scale != 1.0
                    && ui
                        .button("Reset")
                        .on_hover_text("Reset to 100% scale")
                        .clicked()
                {
                    self.conf.ui_scale = 1.0;
                }
            });
            // #[cfg(not(feature = "geode"))]
            ui.horizontal(|ui| {
                help_text(
                    ui,
                    "Use an alternate button hook for bot compatibility",
                    |ui| ui.checkbox(&mut self.conf.use_alternate_hook, "Use alternate hook"),
                );
            });
            #[cfg(not(feature = "geode"))]
            help_text(ui, "Show debug console", |ui| {
                if ui
                    .checkbox(&mut self.conf.show_console, "Show console")
                    .changed()
                {
                    if self.conf.show_console {
                        self.maybe_alloc_console();
                    } else {
                        let _ = unsafe { FreeConsole() };
                    }
                }
            });
            help_text(
                ui,
                "Automatically save configuration changes every 5 seconds.\n\
                If this is disabled, the config will still be saved on graceful exit",
                |ui| ui.checkbox(&mut self.conf.autosave_config, "Auto-save config"),
            );

            egui::ComboBox::from_label("Toast Visibility")
                .selected_text(self.conf.toast_visibility.text())
                .show_ui(ui, |ui| {
                    ui.selectable_value(
                        &mut self.conf.toast_visibility,
                        ToastVisibility::AlwaysVisible,
                        ToastVisibility::AlwaysVisible.text(),
                    );
                    ui.selectable_value(
                        &mut self.conf.toast_visibility,
                        ToastVisibility::VisibleWhenOpen,
                        ToastVisibility::VisibleWhenOpen.text(),
                    );
                    ui.selectable_value(
                        &mut self.conf.toast_visibility,
                        ToastVisibility::NeverVisible,
                        ToastVisibility::NeverVisible.text(),
                    );
                });

            ui.horizontal(|ui| {
                ui.style_mut().spacing.item_spacing.x = 4.0;
                if ui
                    .button("Save")
                    .on_hover_text("Save the current configuration")
                    .clicked()
                {
                    self.conf.save();
                    self.toasts
                        .lock()
                        .add(Toast::success("Saved configuration to .zcb/config.json"));
                }
                ui.style_mut().spacing.item_spacing.x = 4.0;
                if ui
                    .button("Load")
                    .on_hover_text("Load the config from .zcb/config.json")
                    .clicked()
                {
                    let conf = Config::load();
                    if let Ok(conf) = conf {
                        self.conf = conf;
                        self.apply_config();
                        self.toasts
                            .lock()
                            .add(Toast::success("Loaded configuration from .zcb/config.json"));
                    } else if let Err(e) = conf {
                        show_error_dialog(modal.clone(), "Failed to load config!", &e.to_string());
                    }
                }
                ui.style_mut().spacing.item_spacing.x = 4.0;
                if ui
                    .button("Reset")
                    .on_hover_text("Reset the current configuration to defaults")
                    .clicked()
                {
                    let prev_stage = self.conf.stage;
                    self.conf = Config::default();
                    self.conf.stage = prev_stage; // don't switch current tab
                    self.apply_config();
                    self.toasts
                        .lock()
                        .add(Toast::info("Reset configuration to defaults"));
                }
                if ui
                    .button("Open folder")
                    .on_hover_text("Open .zcb folder")
                    .clicked()
                {
                    let _ = std::fs::create_dir_all(".zcb")
                        .map_err(|e| log::error!("failed to create .zcb: {e}"));
                    let _ = Command::new("explorer").arg(".zcb").spawn().map_err(|e| {
                        show_error_dialog(modal, "Failed to open folder!", &e.to_string());
                    });
                }
            });
        });
        ui.hyperlink_to("Join the Discord server!", "https://discord.gg/BRVVVzxESu");
        ui.allocate_space(ui.available_size() - vec2(0.0, 280.0));
    }

    fn get_device(&mut self) -> Device {
        Device::from_name(&self.env.selected_device).unwrap_or_default()
    }

    fn show_device_switcher(&mut self, ui: &mut egui::Ui) {
        ui.horizontal(|ui| {
            egui::ComboBox::from_label("Output device")
                .selected_text(&self.env.selected_device)
                .show_ui(ui, |ui| {
                    let devices = self.devices.lock().clone();
                    for device in &devices {
                        let is_selected = &self.env.selected_device == device;
                        if ui
                            .selectable_value(&mut self.env.selected_device, device.clone(), device)
                            .clicked()
                            && !is_selected
                        {
                            // start a new mixer on new device
                            log::info!("switching audio device to \"{device}\"");
                            self.maybe_init_kittyaudio();
                            self.play_noise();
                            self.env.save();
                            self.toasts
                                .lock()
                                .add(Toast::success(format!("Switched device to \"{device}\"")));
                            //kind: ToastKind::Success,
                            //text: format!("Switched device to \"{device}\"").into(),
                            //options: ToastOptions::default().duration_in_seconds(3.0),);
                        }
                    }
                })
                .response
                .on_disabled_hover_text("Not available with FMOD");
            if ui
                .button("Reset")
                .on_hover_text("Reset to the default audio device")
                .clicked()
            {
                self.mixer = Mixer::new();
                self.mixer.init();
                if let Ok(name) = Device::Default.name() {
                    self.env.selected_device = name.clone();
                    self.toasts
                        .lock()
                        .add(Toast::success(format!("Switched device to \"{name}\"")));
                }
                self.play_noise();
                self.env.save();
                log::debug!("reset audio device");
            }
        });
    }

    fn play_noise(&mut self) {
        let stop_kittyaudio_noise = |noise_sound: &mut Option<SoundHandle>| {
            if let Some(noise_sound) = noise_sound {
                noise_sound.set_playback_rate(PlaybackRate::Factor(1.0));
                noise_sound.set_loop_enabled(false);
                noise_sound.seek_to_end();
            }
            *noise_sound = None;
        };
        // let stop_fmod_noise = |fmodn: &mut *mut FMOD_CHANNEL| {
        //     unsafe { FMOD_Channel_Stop(*fmodn) };
        //     *fmodn = std::ptr::null_mut();
        // };
        let mut start_kittyaudio_noise = |noise_sound: &mut Option<SoundHandle>| {
            if let Some(mut noise) = self.clickpack.noise.clone() {
                noise.set_volume(self.conf.noise_volume as f32);
                noise.set_loop_enabled(true);
                let frames = noise.frames.len().saturating_sub(1);
                noise.set_loop_index(0..=frames);
                noise.set_playback_rate(PlaybackRate::Factor(self.conf.noise_speedhack));
                *noise_sound = Some(self.mixer.play(noise.sound));
            }
        };
        /*
        let start_fmod_noise = |fmodn: &mut *mut FMOD_CHANNEL| unsafe {
            if let Some(noise) = self.noise.clone() {
                // get sound length
                // let mut length = 0u32;
                // FMOD_Sound_GetLength(noise.fmod_sound, &mut length, FMOD_TIMEUNIT_PCM);

                // set loop points for sound
                FMOD_Sound_SetLoopCount(noise.fmod_sound, i32::MAX);
                // FMOD_Sound_SetLoopPoints(
                //     noise.fmod_sound,
                //     0,
                //     FMOD_TIMEUNIT_PCM,
                //     length,
                //     FMOD_TIMEUNIT_PCM,
                // );

                // play the sound
                FMOD_System_PlaySound(
                    self.system,
                    noise.fmod_sound,
                    std::ptr::null_mut(),
                    0,
                    fmodn,
                );

                // update channel
                FMOD_Channel_SetVolume(*fmodn, self.conf.noise_volume);
                // FMOD_Channel_SetLoopPoints(*fmodn, 0, FMOD_TIMEUNIT_PCM, 1024, FMOD_TIMEUNIT_PCM);
                FMOD_Channel_SetLoopCount(*fmodn, i32::MAX);
                FMOD_Channel_SetPitch(*fmodn, self.conf.noise_speedhack as f32);
                FMOD_System_Update(self.system);
            }
        };
        */

        stop_kittyaudio_noise(&mut self.noise_sound);
        // stop_fmod_noise(&mut self.fmod_noise_sound);

        if self.conf.play_noise && (self.conf.enabled || self.conf.play_noise_when_disabled) {
            if self.conf.use_fmod {
                // start_fmod_noise(&mut self.fmod_noise_sound);
            } else {
                start_kittyaudio_noise(&mut self.noise_sound);
            }
        }
    }

    fn open_noise_toggle_toast(&self) {
        self.toasts.lock().add(Toast::info(if self.conf.play_noise {
            "Playing noise"
        } else {
            "Stopped playing noise"
        }));
    }

    #[inline]
    fn is_loading_clickpack(&self) -> bool {
        self.is_loading_clickpack.load(Ordering::Relaxed)
    }

    fn show_audio_window(&mut self, ui: &mut egui::Ui) {
        ui.add_enabled_ui(
            self.clickpack.has_noise() && !self.is_loading_clickpack(),
            |ui| {
                ui.horizontal(|ui| {
                    if ui
                        .checkbox(&mut self.conf.play_noise, "Play noise")
                        .on_disabled_hover_text("Your clickpack doesn't have a noise file")
                        .on_hover_text("Play the noise file")
                        .changed()
                    {
                        self.play_noise();
                        self.open_noise_toggle_toast();
                    }

                    if drag_value(
                        ui,
                        &mut self.conf.noise_volume,
                        "Noise volume",
                        0.0..=f64::INFINITY,
                        "",
                    )
                    .drag_stopped()
                    {
                        self.play_noise(); // restart noise
                    }
                });
            },
        );

        /*
        help_text(
            ui,
            "Use the internal audio engine for integration with internal recorders",
            |ui| {
                if ui.checkbox(&mut self.conf.use_fmod, "Use FMOD").changed() {
                    if self.conf.use_fmod {
                        log::info!("destroying kittyaudio mixer");
                        self.mixer = Mixer::new();
                    } else {
                        self.maybe_init_kittyaudio();
                    }
                    self.play_noise();
                }
            },
        );
        */
        ui.add_enabled_ui(!self.conf.use_fmod, |ui| self.show_device_switcher(ui));

        ui.separator();

        ui.collapsing("Timings", |ui| {
            help_text(
                ui,
                "Use in-game level time instead of real time.\n\
                Less realistic with practice mode or speedhack.\n\
                Enable 'Enhanced Recording Sync' for better video recording synchronization.",
                |ui| {
                    ui.checkbox(&mut self.conf.use_ingame_time, "Use in-game time");
                },
            );

            // Store the value to avoid borrowing issues
            let use_ingame_time = self.conf.use_ingame_time;

            // Enhanced recording synchronization options
            ui.add_enabled_ui(use_ingame_time, |ui| {
                help_text(
                    ui,
                    "Enables advanced timing synchronization for recording gameplay.\n\
                    Reduces audio desync in recorded videos by compensating for:\n\
                    • Frame rate variations during recording\n\
                    • Game pause/resume states\n\
                    • Recording software timing interference\n\
                    • Time drift between game and real time",
                    |ui| {
                        ui.checkbox(&mut self.conf.enhanced_recording_sync, "Enhanced Recording Sync");
                    },
                );

                if self.conf.enhanced_recording_sync {
                    ui.indent("recording_sync_options", |ui| {
                        help_text(
                            ui,
                            "Controls how much timing smoothing is applied (0.0 = no smoothing, 1.0 = maximum smoothing).\n\
                            Higher values provide more stable timing but may feel less responsive.",
                            |ui| {
                                drag_value(
                                    ui,
                                    &mut self.conf.time_smoothing_factor,
                                    "Time Smoothing",
                                    0.0..=1.0,
                                    "",
                                );
                            },
                        );

                        help_text(
                            ui,
                            "Threshold in seconds for detecting game pauses.\n\
                            Lower values detect shorter pauses but may cause false positives.",
                            |ui| {
                                drag_value(
                                    ui,
                                    &mut self.conf.pause_detection_threshold,
                                    "Pause Detection Threshold (s)",
                                    0.01..=1.0,
                                    "",
                                );
                            },
                        );
                    });
                }

                // Dual Timing System Controls
                ui.separator();
                ui.label(RichText::new("Dual Timing System").strong());

                help_text(
                    ui,
                    "Controls how audio timing is handled for different use cases:\n\
                    • Responsive: Prioritizes immediate audio feedback (best for live play)\n\
                    • Synchronized: Prioritizes perfect recording sync (best for videos)\n\
                    • Hybrid: Balances both based on other settings (recommended)",
                    |ui| {
                        egui::ComboBox::from_label("Timing Mode")
                            .selected_text(self.conf.timing_mode.text())
                            .show_ui(ui, |ui| {
                                ui.selectable_value(
                                    &mut self.conf.timing_mode,
                                    TimingMode::Responsive,
                                    TimingMode::Responsive.text(),
                                );
                                ui.selectable_value(
                                    &mut self.conf.timing_mode,
                                    TimingMode::Synchronized,
                                    TimingMode::Synchronized.text(),
                                );
                                ui.selectable_value(
                                    &mut self.conf.timing_mode,
                                    TimingMode::Hybrid,
                                    TimingMode::Hybrid.text(),
                                );
                            });
                    },
                );

                help_text(
                    ui,
                    "Enables instantaneous audio response that bypasses smoothing for immediate feedback.\n\
                    When enabled, audio plays immediately upon button press with 0ms delay.\n\
                    Disable for perfect recording synchronization at the cost of slight input delay.",
                    |ui| {
                        ui.checkbox(&mut self.conf.instant_audio_response, "Instant Audio Response");
                    },
                );

                help_text(
                    ui,
                    "Compensates for input latency by playing audio slightly earlier.\n\
                    Positive values play audio earlier, negative values play audio later.\n\
                    Adjust based on your system's input latency characteristics.",
                    |ui| {
                        drag_value(
                            ui,
                            &mut self.conf.input_latency_compensation,
                            "Input Latency Compensation (s)",
                            -0.1..=0.1,
                            "",
                        );
                    },
                );

                // Show timing diagnostics button
                if ui.button("Show Timing Diagnostics").clicked() {
                    let diagnostics = self.get_timing_diagnostics();
                    log::info!("Timing Diagnostics:\n{}", diagnostics);
                    self.toasts.lock().add(Toast::info("Timing diagnostics logged to console"));
                }

                // Show audio system diagnostics button
                if ui.button("Show Audio System Status").clicked() {
                    let audio_status = self.get_audio_system_status();
                    log::info!("Audio System Status:\n{}", audio_status);
                    self.toasts.lock().add(Toast::info("Audio system status logged to console"));
                }
            });

            // Enhanced pause-aware audio controls
            ui.separator();
            ui.label(RichText::new("Pause-Aware Audio System").strong());

            help_text(
                ui,
                "When enabled, currently playing clickpack audio will continue to play naturally when the game is paused,\n\
                rather than being immediately cut off. New audio will not start during pause.\n\
                This prevents jarring audio cutoffs during pause/resume cycles and improves the overall audio experience.",
                |ui| {
                    ui.checkbox(&mut self.conf.allow_audio_finish_on_pause, "Allow Audio to Finish on Pause");
                },
            );

            help_text(
                ui,
                "Enables advanced audio system recovery features that handle rapid pause/resume cycles more gracefully.\n\
                This includes action queuing during pauses and automatic audio system reset when needed.",
                |ui| {
                    ui.checkbox(&mut self.conf.enable_audio_system_recovery, "Enable Audio System Recovery");
                },
            );

            ui.add_enabled_ui(self.conf.enable_audio_system_recovery, |ui| {
                help_text(
                    ui,
                    "Time threshold for debouncing pause state changes to prevent audio instability.\n\
                    Lower values are more responsive but may cause issues with rapid pause/resume cycles.",
                    |ui| {
                        drag_value(
                            ui,
                            &mut self.conf.pause_debounce_threshold,
                            "Pause Debounce Threshold (s)",
                            0.01..=0.5,
                            "",
                        );
                    },
                );

                help_text(
                    ui,
                    "Maximum number of rapid pause/resume cycles before triggering an audio system reset.\n\
                    This prevents audio system instability during very rapid state changes.",
                    |ui| {
                        ui.horizontal(|ui| {
                            ui.add(
                                DragValue::new(&mut self.conf.rapid_pause_threshold)
                                    .clamp_range(3..=20)
                                    .speed(0.1),
                            );
                            ui.label("Rapid Pause Threshold");
                        });
                    },
                );
            });
            help_text(
                ui,
                "Plays platformer left/right sounds even if your clickpack doesn't have them",
                |ui| {
                    ui.checkbox(
                        &mut self.conf.force_playing_platformer,
                        "Force playing platformer sounds",
                    );
                },
            );
            help_text(
                ui,
                "Plays player 2 sounds outside 2-player levels.\n\
                This will not have any effect if you use alternate hook!",
                |ui| {
                    ui.checkbox(
                        &mut self.conf.force_player2_sounds,
                        "Force playing player 2 sounds",
                    );
                },
            );
            help_text(
                ui,
                "Makes both platformer sounds have separate timings. Usually sounds bad",
                |ui| {
                    ui.checkbox(
                        &mut self.conf.decouple_platformer,
                        "Decouple platformer sounds",
                    );
                },
            );
            help_text(ui, "Releases all held buttons on death", |ui| {
                ui.checkbox(
                    &mut self.conf.release_buttons_on_death,
                    "Release buttons on death",
                );
            });
            if self.conf.release_buttons_on_death {
                drag_value(
                    ui,
                    &mut self.conf.death_release_delay,
                    "Release delay (sec)",
                    0.0..=f64::INFINITY,
                    "Delay before releasing buttons on death in seconds",
                );
                ui.horizontal(|ui| {
                    drag_value(
                        ui,
                        &mut self.conf.death_release_delay_offset,
                        "+/- (sec)",
                        0.0..=f64::INFINITY,
                        "Random offset for the death release delay in seconds",
                    );
                    ui.checkbox(&mut self.conf.death_release_delay_neg, "Negative?");
                });
            }

            ui.separator();

            // Timing values section - moved to end to avoid borrowing conflicts
            let timings_copy = self.conf.timings.clone();
            drag_value(
                ui,
                &mut self.conf.timings.hard,
                "Hard timing",
                timings_copy.regular..=f64::INFINITY,
                "Anything above this time between clicks plays hardclicks/hardreleases",
            );
            drag_value(
                ui,
                &mut self.conf.timings.regular,
                "Regular timing",
                timings_copy.soft..=timings_copy.hard,
                "Anything above this time between clicks plays clicks/releases",
            );
            drag_value(
                ui,
                &mut self.conf.timings.soft,
                "Soft timing",
                0.0..=timings_copy.regular,
                "Anything above this time between clicks plays softclicks/softreleases",
            );
            ui.label(format!(
                "Any value smaller than {:.2?} plays microclicks/microreleases",
                Duration::from_secs_f64(self.conf.timings.soft),
            ))
        });

        ui.collapsing("Ignored click types", |ui| {
            ui.label(
                "Ignored click types will not be played. This can be useful for \
                disabling microreleases, for example",
            );
            let i = &mut self.conf.ignored_click_types;
            ui.checkbox(&mut i.hardclicks, "Hardclicks");
            ui.checkbox(&mut i.hardreleases, "Hardreleases");
            ui.checkbox(&mut i.clicks, "Clicks");
            ui.checkbox(&mut i.releases, "Releases");
            ui.checkbox(&mut i.softclicks, "Softclicks");
            ui.checkbox(&mut i.softreleases, "Softreleases");
            ui.checkbox(&mut i.microclicks, "Microclicks");
            ui.checkbox(&mut i.microreleases, "Microreleases");
            if i.any_ignored() && ui.button("Reset").clicked() {
                *i = IgnoredClickTypes::default();
            }
        });

        ui.collapsing("Pitch variation", |ui| {
            ui.label(
                "Pitch variation can make clicks sound more realistic by \
                    changing their pitch randomly.",
            );
            ui.checkbox(&mut self.conf.pitch_enabled, "Enable pitch variation");
            ui.add_enabled_ui(self.conf.pitch_enabled, |ui| {
                let p = &mut self.conf.pitch;
                drag_value(
                    ui,
                    &mut p.from,
                    "Minimum pitch",
                    0.0..=p.to,
                    "Minimum pitch value, 1.0 means no change",
                );
                drag_value(
                    ui,
                    &mut p.to,
                    "Maximum pitch",
                    p.from..=f64::INFINITY,
                    "Maximum pitch value, 1.0 means no change",
                );
            });
        });

        ui.collapsing("Volume settings", |ui| {
            help_text(
                ui,
                "Cut overlapping click sounds,\n\
                changes the sound significantly in spams",
                |ui| ui.checkbox(&mut self.conf.cut_sounds, "Cut sounds"),
            );
            if self.conf.cut_sounds {
                help_text(ui, "Allow clicks to be cut by releases", |ui| {
                    ui.checkbox(&mut self.conf.cut_by_releases, "Cut by releases")
                });
            }
            let vol = &mut self.conf.volume_settings;
            drag_value(
                ui,
                &mut vol.global_volume,
                "Global volume",
                0.0..=f64::INFINITY,
                "Constant volume multiplier for all sounds",
            );
            drag_value(
                ui,
                &mut vol.volume_var,
                "Volume variation",
                0.0..=f64::INFINITY,
                "Random volume variation (+/-)",
            );
            drag_value(
                ui,
                &mut vol.platformer_volume_factor,
                "Platformer volume factor",
                f64::NEG_INFINITY..=f64::INFINITY,
                "Multiplier of the platformer sound volume. If this is 0.5, \
                platformer sounds will be played at half volume",
            );
        });

        ui.collapsing("Spam volume changes", |ui| {
            ui.label("This can be used to lower volume in spams");
            let vol = &mut self.conf.volume_settings;
            help_text(ui, "Apply this logic to releases", |ui| {
                ui.checkbox(&mut vol.change_releases_volume, "Change releases volume")
            });
            drag_value(
                ui,
                &mut vol.spam_time,
                "Spam time",
                0.0..=f64::INFINITY,
                "Time between clicks which are considered spam clicks",
            );
            drag_value(
                ui,
                &mut vol.spam_vol_offset_factor,
                "Spam volume offset factor",
                f64::NEG_INFINITY..=f64::INFINITY,
                "The value which the volume offset factor is multiplied by",
            );
            drag_value(
                ui,
                &mut vol.max_spam_vol_offset,
                "Maximum volume offset",
                f64::NEG_INFINITY..=f64::INFINITY,
                "The maximum value of the volume offset",
            );
        });

        ui.collapsing("Speed", |ui| {
            ui.label("Adjust audio speed/pitch");
            ui.horizontal(|ui| {
                drag_value(
                    ui,
                    &mut self.conf.click_speedhack,
                    "Click speed",
                    0.0..=f64::INFINITY,
                    "Speed multiplier for clicks/releases",
                );
                if self.conf.click_speedhack != 1.0 && ui.button("Reset").clicked() {
                    self.conf.click_speedhack = 1.0;
                }
            });
            ui.horizontal(|ui| {
                if drag_value(
                    ui,
                    &mut self.conf.noise_speedhack,
                    "Noise speed",
                    0.0..=f64::INFINITY,
                    "Speed multiplier for noise. Only useful if your clickpack has a noise file",
                )
                .drag_stopped()
                {
                    self.play_noise();
                }
                if self.conf.noise_speedhack != 1.0 && ui.button("Reset").clicked() {
                    self.conf.noise_speedhack = 1.0;
                    self.play_noise();
                }
            });
            // help_text(ui, "Synchronize click speedhack with game speed", |ui| {
            //     ui.checkbox(&mut self.conf.sync_speed_with_game, "Sync speed with game")
            // });
        });

        ui.collapsing("Advanced", |ui| {
            // let last_bufsize = self.mixer.renderer.guard().last_buffer_size;
            // ui.label(format!("Real buffer size: {last_bufsize}"));
            help_text(
                ui,
                "Keep playing noise even if the clickbot is disabled",
                |ui| {
                    ui.checkbox(&mut self.conf.play_noise_when_disabled, "Play noise when disabled");
                },
            );

            let prev_bufsize = self.conf.buffer_size;
            help_text(
                ui,
                "Audio buffer size in samples. Lower value means lower latency.\n\
                Click \"Apply\" below to apply changes (if any)",
                |ui| {
                    ui.label("Buffer size");
                },
            );
            if u32_edit_field_min1(ui, &mut self.conf.buffer_size).changed() {
                self.buffer_size_changed = prev_bufsize != self.conf.buffer_size;
            }

            if self.buffer_size_changed {
                ui.horizontal(|ui| {
                    if ui
                        .button("Apply")
                        .on_hover_text("Apply buffer size changes")
                        .clicked()
                    {
                        if !self.conf.use_fmod {
                            self.maybe_init_kittyaudio();
                            self.play_noise();
                        } else {
                            self.show_fmod_buffersize_warn = true;
                        }
                        self.buffer_size_changed = false;
                    }

                    if self.conf.buffer_size > 300_000 {
                        ui.label(
                            RichText::new("WARN: Using a high buffer size might cause instability")
                                .color(Color32::YELLOW),
                        );
                    }
                });
            }
            if self.show_fmod_buffersize_warn && self.conf.buffer_size != self.startup_buffer_size {
                ui.label(
                    RichText::new("WARN: Restart the game to apply FMOD buffer size changes")
                        .color(Color32::YELLOW),
                );
            }
            if self.conf.use_fmod && self.startup_buffer_size < 10 {
                ui.label(
                    "If you don't hear any audio, it might be because your buffer size is set too low. \
                    The recommended value for FMOD is 10."
                );
            }
        });

        ui.allocate_space(vec2(100.0, 0.0));
    }

    fn apply_config(&mut self) {
        self.maybe_init_kittyaudio();
        self.play_noise();

        #[cfg(not(feature = "geode"))]
        self.maybe_alloc_console();
    }

    fn unload_clickpack(&mut self) {
        self.clickpack = Clickpack::default();
        self.stop_noise();
    }

    fn stop_noise(&mut self) {
        let prev_play_noise = self.conf.play_noise;
        self.conf.play_noise = false;
        self.play_noise();
        self.conf.play_noise = prev_play_noise;
    }

    /// Reset the audio system to recover from issues during rapid pause/resume cycles
    fn reset_audio_system(&mut self) {
        log::info!("Resetting audio system due to rapid pause/resume cycles");

        // Stop all currently playing sounds immediately
        self.stop_all_sounds_immediately();

        // Reinitialize the mixer
        if !self.conf.use_fmod {
            self.maybe_init_kittyaudio();
        }

        // Reset audio state
        self.audio_system_needs_reset = false;
        self.rapid_pause_resume_count = 0;
        self.pending_audio_actions.clear();

        // Restart noise if it was playing
        self.play_noise();

        log::info!("Audio system reset completed");
    }

    /// Stop all sounds immediately without seeking to end (for emergency reset)
    fn stop_all_sounds_immediately(&mut self) {
        if !self.conf.use_fmod {
            // Create a new mixer to immediately stop all sounds
            let old_mixer = std::mem::replace(&mut self.mixer, Mixer::new());
            drop(old_mixer); // This will stop all sounds immediately
        }

        // Reset noise sound handle
        self.noise_sound = None;
    }

    /// Process pending audio actions that were queued during pause states
    fn process_pending_audio_actions(&mut self) {
        if self.pending_audio_actions.is_empty() {
            return;
        }

        log::debug!("Processing {} pending audio actions", self.pending_audio_actions.len());

        let actions = std::mem::take(&mut self.pending_audio_actions);
        let mut processed_count = 0;

        for action in actions {
            match action {
                PendingAudioAction::Play { button, player2, push, timestamp } => {
                    // Only process recent actions (within 150ms for better responsiveness)
                    if timestamp.elapsed().as_millis() < 150 {
                        unsafe { self.on_action(button, player2, push); }
                        processed_count += 1;
                    }
                }
                PendingAudioAction::Stop { immediate } => {
                    if immediate {
                        self.stop_all_sounds_immediately();
                    } else {
                        self.stop_noise();
                    }
                    processed_count += 1;
                }
                PendingAudioAction::Reset => {
                    self.reset_audio_system();
                    processed_count += 1;
                }
            }
        }

        if processed_count > 0 {
            log::debug!("Processed {} audio actions after resume", processed_count);
        }
    }

    /// Check if audio system recovery is needed and perform it
    fn check_and_recover_audio_system(&mut self) {
        if !self.conf.enable_audio_system_recovery {
            return;
        }

        if self.audio_system_needs_reset {
            self.reset_audio_system();
        }

        // Process any pending actions
        self.process_pending_audio_actions();
    }

    /// Get comprehensive audio system status for diagnostics
    fn get_audio_system_status(&self) -> String {
        let mut status = String::new();

        status.push_str("=== Audio System Status ===\n");
        status.push_str(&format!("Game Paused: {}\n", self.is_game_paused));
        status.push_str(&format!("Audio System Needs Reset: {}\n", self.audio_system_needs_reset));
        status.push_str(&format!("Rapid Pause/Resume Count: {}\n", self.rapid_pause_resume_count));
        status.push_str(&format!("Pending Audio Actions: {}\n", self.pending_audio_actions.len()));
        status.push_str(&format!("Last Pause State: {}\n", self.last_pause_state));

        let debounce_elapsed = self.pause_state_debounce_timer.elapsed().as_millis();
        status.push_str(&format!("Debounce Timer Elapsed: {}ms\n", debounce_elapsed));

        let pause_elapsed = self.pause_detected_time.elapsed().as_millis();
        status.push_str(&format!("Time Since Last Pause Detection: {}ms\n", pause_elapsed));

        status.push_str("\n=== Configuration ===\n");
        status.push_str(&format!("Allow Audio Finish on Pause: {}\n", self.conf.allow_audio_finish_on_pause));
        status.push_str(&format!("Enable Audio System Recovery: {}\n", self.conf.enable_audio_system_recovery));
        status.push_str(&format!("Pause Detection Threshold: {:.3}s\n", self.conf.pause_detection_threshold));
        status.push_str(&format!("Pause Debounce Threshold: {:.3}s\n", self.conf.pause_debounce_threshold));
        status.push_str(&format!("Rapid Pause Threshold: {}\n", self.conf.rapid_pause_threshold));

        status.push_str("\n=== Audio Engine ===\n");
        status.push_str(&format!("Using FMOD: {}\n", self.conf.use_fmod));
        status.push_str(&format!("Buffer Size: {}\n", self.conf.buffer_size));
        status.push_str(&format!("Cut Sounds: {}\n", self.conf.cut_sounds));
        status.push_str(&format!("Noise Sound Active: {}\n", self.noise_sound.is_some()));

        if !self.conf.use_fmod {
            let renderer_guard = self.mixer.renderer.guard();
            status.push_str(&format!("Active Sounds: {}\n", renderer_guard.sounds.len()));
        }

        status
    }

    /// Force immediate audio system recovery (emergency reset)
    /// This can be called externally when audio issues are detected
    pub fn force_audio_system_recovery(&mut self) {
        log::warn!("Forcing immediate audio system recovery");

        // Mark for immediate reset
        self.audio_system_needs_reset = true;
        self.rapid_pause_resume_count = self.conf.rapid_pause_threshold;

        // Clear all pending actions to prevent conflicts
        self.pending_audio_actions.clear();

        // Perform immediate recovery
        self.check_and_recover_audio_system();

        log::info!("Emergency audio system recovery completed");
    }

    fn load_clickpack_thread(
        err_fn: impl Fn(anyhow::Error),
        dir: &Path,
        is_loading_clickpack: Arc<AtomicBool>,
        load_for: LoadClickpackFor,
    ) {
        unsafe {
            is_loading_clickpack.store(true, Ordering::Relaxed);
            if load_for == LoadClickpackFor::All {
                BOT.unload_clickpack();
            } else {
                BOT.stop_noise();
            }
            let _ = BOT.clickpack.load_from_path(dir, load_for).map_err(|e| {
                log::error!("failed to load clickpack: {e}");
                err_fn(e);
            });
            BOT.play_noise();
            is_loading_clickpack.store(false, Ordering::Relaxed);
        }
    }

    fn select_clickpack_combobox(&mut self, ui: &mut egui::Ui, modal: Arc<Mutex<Modal>>) {
        let ellipsis = if self.clickpack.name.len() <= 14 {
            self.clickpack.name.clone()
        } else {
            format!("{:.14}…", self.clickpack.name)
        };
        egui::ComboBox::from_label("Select clickpack")
            .selected_text(ellipsis)
            .show_ui(ui, |ui| {
                for dirname in &self.clickpacks {
                    let is_loading_clickpack = self.is_loading_clickpack.clone();
                    let load_for = self.conf.load_clickpack_for;
                    let path = PathBuf::from(".zcb").join("clickpacks").join(dirname);
                    if ui
                        .selectable_label(&self.clickpack.name == dirname, dirname)
                        .clicked()
                    {
                        let modal_moved = modal.clone();
                        let dirname_moved = dirname.to_string();
                        std::thread::spawn(move || {
                            Self::load_clickpack_thread(
                                |e| {
                                    show_error_dialog(
                                        modal_moved.clone(),
                                        "Failed to load clickpack!",
                                        &e.to_string(),
                                    );
                                },
                                &path,
                                is_loading_clickpack,
                                load_for,
                            );
                            unsafe { BOT.env.update(ClickpackEnv::Name(dirname_moved), load_for) };
                        });
                    }
                }
            });
    }

    fn select_clickpack_button(&mut self, ui: &mut egui::Ui, modal: Arc<Mutex<Modal>>) -> bool {
        if !self.clickpacks.is_empty() {
            self.select_clickpack_combobox(ui, modal);
            return true;
        }
        ui.horizontal(|ui| {
            if ui
                .button("Select clickpack")
                .on_disabled_hover_text("Please wait…")
                .clicked()
            {
                let is_loading_clickpack = self.is_loading_clickpack.clone();
                let load_for = self.conf.load_clickpack_for;
                std::thread::spawn(move || {
                    let Some(dir) = FileDialog::new().pick_folder() else {
                        return;
                    };
                    log::debug!("selected clickpack {dir:?}");
                    Self::load_clickpack_thread(
                        |e| {
                            show_error_dialog(
                                modal.clone(),
                                "Failed to load clickpack!",
                                &e.to_string(),
                            );
                        },
                        &dir,
                        is_loading_clickpack,
                        load_for,
                    );
                    unsafe {
                        BOT.env.update(ClickpackEnv::Path(dir), load_for);
                    }
                });
            }
            if self.clickpack.num_sounds != 0 {
                ui.label(format!("Selected clickpack: \"{}\"", self.clickpack.name));
            } else {
                ui.label("…or put clickpacks in .zcb/clickpacks");
            }
        });
        false
    }

    fn show_select_clickpack_for_combobox(&mut self, ui: &mut egui::Ui) {
        ui.horizontal(|ui| {
            ui.label("Select clickpack for:");
            help_text(
                ui,
                "Choose a player to load the clickpack for.\n\
                E.g. if you choose Left1, the clickpack will be used for platformer sounds",
                |ui| {
                    egui::ComboBox::new("select_clickpack_for_combobox", "")
                        .selected_text(format!("{:?}", self.conf.load_clickpack_for))
                        .show_ui(ui, |ui| {
                            for load_for in [
                                LoadClickpackFor::All,
                                LoadClickpackFor::Player1,
                                LoadClickpackFor::Player2,
                                LoadClickpackFor::Left1,
                                LoadClickpackFor::Left2,
                                LoadClickpackFor::Right1,
                                LoadClickpackFor::Right2,
                            ] {
                                ui.selectable_value(
                                    &mut self.conf.load_clickpack_for,
                                    load_for,
                                    format!("{load_for:?}"),
                                );
                            }
                        });
                },
            );
        });
    }

    fn show_clickpack_window(&mut self, ui: &mut egui::Ui, modal: Arc<Mutex<Modal>>) {
        let is_loading_clickpack = self.is_loading_clickpack();
        if is_loading_clickpack {
            ui.horizontal(|ui| {
                ui.label("Loading clickpack…");
                ui.add(egui::Spinner::new());
            });
        }

        ui.add_enabled_ui(!is_loading_clickpack, |ui| {
            if !self.clickpacks.is_empty() {
                help_text(
                    ui,
                    "If there's no folders inside .zcb/clickpacks,\n\
                    there will be an option to choose the clickpack manually",
                    |ui| {
                        ui.label("Put clickpacks in .zcb/clickpacks");
                    },
                );
            }

            let show_open_folder = |ui: &mut egui::Ui| {
                if ui
                    .button("Open folder")
                    .on_hover_text("Open .zcb/clickpacks")
                    .clicked()
                {
                    let _ = std::fs::create_dir_all(".zcb/clickpacks")
                        .map_err(|e| log::error!("failed to create .zcb/clickpacks: {e}"));
                    let _ = Command::new("explorer")
                        .arg(".zcb\\clickpacks")
                        .spawn()
                        .map_err(|e| log::error!("failed to open .zcb/clickpacks: {e}"));
                }
            };

            self.show_select_clickpack_for_combobox(ui);

            let mut is_combobox = false;
            ui.horizontal(|ui| {
                is_combobox = self.select_clickpack_button(ui, modal);
                if !self.clickpack.name.is_empty() {
                    ui.style_mut().spacing.item_spacing.x = 4.0;
                    if ui.button("🗙").on_hover_text("Unload clickpack").clicked() {
                        self.unload_clickpack();
                        self.env.update(ClickpackEnv::None, LoadClickpackFor::All);
                    }
                }
                if is_combobox {
                    show_open_folder(ui);
                }
            });
            if !is_combobox {
                show_open_folder(ui);
            }
        });

        if self.clickpack.num_sounds != 0 {
            help_text(
                ui,
                "To add player 2 sounds, make a folder called \"player2\" \
                and put sounds for the second player there,\n\
                or use \"Select clickpack for\" to select a \
                seperate clickpack for the second player",
                |ui| {
                    ui.label(format!("{} sounds", self.clickpack.num_sounds));
                },
            );
        }
        ui.separator();
        ui.collapsing("ClickpackDB", |ui| {
            ui.label(
                "ClickpackDB is a collection of 300+ clickpacks \
                that can be easily downloaded from within ZCB Live.",
            );
            if self.clickpack_db_open {
                if ui
                    .button("Close ClickpackDB")
                    .on_hover_text("This can also be done by clicking ✖ on the ClickpackDB window")
                    .clicked()
                {
                    self.clickpack_db_open = false;
                }
            } else if ui.button("Open ClickpackDB…").clicked() {
                self.clickpack_db_open = true;
            }
        });
        // ui.hyperlink_to(
        //     "Get more clickpacks in the Discord server!",
        //     "https://discord.gg/BRVVVzxESu",
        // );

        if !is_loading_clickpack && self.is_in_level {
            ui.collapsing("Debug", |ui| {
                ui.label("Last click times and types:");
                egui::Grid::new("times_grid")
                    .num_columns(2)
                    .min_col_width(130.0)
                    .striped(true)
                    .show(ui, |ui| {
                        for times in [
                            self.prev_times.jump,
                            self.prev_times.left,
                            self.prev_times.right,
                        ] {
                            for t in times {
                                ui.label(format!("{:.3?} | {:?}", t.time, t.typ));
                            }
                            ui.end_row();
                        }
                    });
                ui.label(format!(
                    "Last pitch: {:.4} ({}..={})",
                    self.prev_pitch, self.conf.pitch.from, self.conf.pitch.to
                ));
                ui.label(format!(
                    "Last volume: {:.4} (+/- {} * {})",
                    self.prev_volume,
                    self.conf.volume_settings.volume_var,
                    self.conf.volume_settings.global_volume
                ));
                ui.label(format!(
                    "Last spam volume offset: -{:.4}",
                    self.prev_spam_offset
                ));

                let format_path_keep_root = |path: &Path| path.to_string_lossy().replace('\\', "/");

                ui.label(format!(
                    "Clickpack path: {:?}",
                    format_path_keep_root(&self.clickpack.path)
                ));
            });
        }
    }

    fn show_clickpackdb_window(&mut self, ctx: &egui::Context, modal: Arc<Mutex<Modal>>) {
        if !self.clickpack_db_open {
            return;
        }
        if std::mem::take(&mut self.clickpack_db.has_refreshed) {
            log::debug!("doing clickpack reload for clickpackdb");
            let _ = self
                .reload_clickpacks()
                .map_err(|e| log::error!("failed to reload clickpacks for clickpackdb: {e}"));
        }
        egui::Window::new("ClickpackDB")
            .open(&mut self.clickpack_db_open)
            .show(ctx, |ui| {
                self.clickpack_db.show(ui, &ureq_get);
                if let Some(select_path) =
                    std::mem::replace(&mut self.clickpack_db.select_clickpack, None)
                {
                    self.conf.load_clickpack_for = LoadClickpackFor::All;
                    let is_loading_clickpack = self.is_loading_clickpack.clone();
                    let modal_moved = modal.clone();
                    std::thread::spawn(move || {
                        Self::load_clickpack_thread(
                            |e| {
                                show_error_dialog(
                                    modal_moved.clone(),
                                    "Failed to load clickpack!",
                                    &e.to_string(),
                                );
                            },
                            &select_path,
                            is_loading_clickpack,
                            LoadClickpackFor::All,
                        );
                        unsafe {
                            BOT.env.update(
                                ClickpackEnv::Name(
                                    select_path
                                        .file_name()
                                        .unwrap_or_default()
                                        .to_string_lossy()
                                        .to_string(),
                                ),
                                LoadClickpackFor::All,
                            )
                        };
                    });
                }
            });
    }
}

impl Drop for Bot {
    fn drop(&mut self) {
        // self.unload_clickpack();
        self.release_fmod()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::thread;
    use std::time::Duration;

    #[test]
    fn test_enhanced_timing_basic() {
        let mut bot = Bot::default();
        bot.conf.use_ingame_time = true;
        bot.conf.enhanced_recording_sync = true;
        bot.conf.time_smoothing_factor = 0.1;
        bot.conf.pause_detection_threshold = 0.1;

        // Initialize timing
        bot.on_init(0);

        // Simulate some time passing
        thread::sleep(Duration::from_millis(50));
        bot.playlayer_time = 0.05; // 50ms game time

        // Update timing state
        bot.update_timing_state();

        // Get synchronized time
        let sync_time = bot.get_synchronized_time(0.05);

        // Should be close to the game time
        assert!((sync_time - 0.05).abs() < 0.01, "Synchronized time should be close to game time");
    }

    #[test]
    fn test_pause_detection() {
        let mut bot = Bot::default();
        bot.conf.use_ingame_time = true;
        bot.conf.enhanced_recording_sync = true;
        bot.conf.pause_detection_threshold = 0.05; // 50ms threshold

        bot.on_init(0);

        // Simulate initial state
        bot.last_game_time = 1.0;
        bot.last_real_time = Instant::now() - Duration::from_millis(200); // 200ms ago

        // Simulate pause (game time didn't advance much, but real time did)
        bot.playlayer_time = 1.01; // Only 10ms game time passed

        let sync_time = bot.get_synchronized_time(1.01);

        // During pause, should maintain stable timing
        assert!(sync_time > 0.0, "Should maintain positive time during pause");
    }

    #[test]
    fn test_enhanced_pause_aware_audio() {
        let mut bot = Bot::default();
        bot.conf.use_ingame_time = true;
        bot.conf.allow_audio_finish_on_pause = true;
        bot.conf.enable_audio_system_recovery = true;
        bot.conf.pause_detection_threshold = 0.05; // 50ms threshold
        bot.conf.pause_debounce_threshold = 0.03; // 30ms debounce
        bot.conf.rapid_pause_threshold = 3;

        bot.on_init(0);

        // Initially not paused
        assert!(!bot.is_game_paused, "Should not be paused initially");
        assert_eq!(bot.rapid_pause_resume_count, 0, "Should have no rapid pause count initially");

        // Simulate pause detection
        bot.last_game_time = 1.0;
        bot.last_real_time = Instant::now() - Duration::from_millis(200); // 200ms ago
        bot.playlayer_time = 1.01; // Only 10ms game time passed

        // Update timing state to detect pause
        bot.update_timing_state();

        // Should now be detected as paused
        assert!(bot.is_game_paused, "Should detect pause state");

        // Test rapid pause/resume detection
        for _ in 0..4 {
            // Simulate rapid state changes
            std::thread::sleep(Duration::from_millis(10));
            bot.update_pause_state_with_debouncing(!bot.is_game_paused, Instant::now());
        }

        // Should trigger audio system reset due to rapid changes
        assert!(bot.audio_system_needs_reset || bot.rapid_pause_resume_count >= bot.conf.rapid_pause_threshold,
                "Should detect rapid pause/resume cycles");

        // Test pending action queuing
        bot.is_game_paused = true;
        bot.pending_audio_actions.push(PendingAudioAction::Play {
            button: crate::clickpack::Button::Jump,
            player2: false,
            push: true,
            timestamp: Instant::now(),
        });

        assert_eq!(bot.pending_audio_actions.len(), 1, "Should have queued action");

        // Test audio system recovery
        bot.check_and_recover_audio_system();

        // After recovery, system should be stable
        if bot.audio_system_needs_reset {
            bot.reset_audio_system();
            assert!(!bot.audio_system_needs_reset, "Audio system should be reset");
            assert_eq!(bot.rapid_pause_resume_count, 0, "Rapid pause count should be reset");
        }

        // Simulate resume
        bot.last_real_time = Instant::now() - Duration::from_millis(50); // 50ms ago
        bot.playlayer_time = 1.1; // Normal game time progression

        // Update timing state to detect resume
        bot.update_timing_state();

        // Should now be detected as resumed
        assert!(!bot.is_game_paused, "Should detect resume state");
    }

    #[test]
    fn test_timing_diagnostics() {
        let mut bot = Bot::default();
        bot.conf.use_ingame_time = true;
        bot.conf.enhanced_recording_sync = true;

        let diagnostics = bot.get_timing_diagnostics();
        assert!(diagnostics.contains("Dual Timing System"), "Should show dual timing system diagnostics");

        bot.conf.enhanced_recording_sync = false;
        let diagnostics = bot.get_timing_diagnostics();
        assert!(diagnostics.contains("Basic in-game time mode"), "Should show basic mode diagnostics");

        bot.conf.use_ingame_time = false;
        let diagnostics = bot.get_timing_diagnostics();
        assert!(diagnostics.contains("Real-time mode"), "Should show real-time mode diagnostics");
    }

    #[test]
    fn test_dual_timing_modes() {
        let mut bot = Bot::default();
        bot.conf.use_ingame_time = true;
        bot.conf.instant_audio_response = true;
        bot.conf.input_latency_compensation = 0.01;

        bot.on_init(0);

        // Test responsive mode
        bot.conf.timing_mode = TimingMode::Responsive;
        let audio_time = bot.audio_time();
        let sync_time = bot.sync_time();

        // In responsive mode, audio time should be real-time based
        assert!((audio_time - bot.level_start.elapsed().as_secs_f64()).abs() < 0.1);

        // Test synchronized mode
        bot.conf.timing_mode = TimingMode::Synchronized;
        bot.playlayer_time = 1.0;
        let sync_audio_time = bot.audio_time();

        // In synchronized mode, audio time should match sync time
        assert!((sync_audio_time - bot.sync_time()).abs() < 0.1);
    }

    #[test]
    fn test_input_compensation() {
        let mut bot = Bot::default();
        bot.conf.instant_audio_response = true;
        bot.conf.input_latency_compensation = 0.05;

        bot.on_init(0);

        // Record some input events
        bot.record_input_event();
        thread::sleep(Duration::from_millis(10));
        bot.record_input_event();

        let compensation = bot.calculate_input_compensation();
        assert!(compensation >= 0.0, "Compensation should be non-negative");
        assert!(compensation <= 0.1, "Compensation should be reasonable");

        // Test predictive timing
        let predictive_time = bot.get_predictive_audio_time();
        let base_time = bot.audio_time();

        // Predictive time should be slightly earlier than base time
        assert!(predictive_time <= base_time, "Predictive time should be earlier or equal to base time");
    }
}
